22 serialization::archive 19 0 0 0 0 40 /home/bluecore/Desktop/Pros/Main Project 40 /home/bluecore/Desktop/Pros/Main Project 0 0 344 0 0 0 579 /**
 * \file pros/imu.hpp
 *
 * Contains prototypes for functions related to the VEX Inertial sensor.
 *
 * Visit https://pros.cs.purdue.edu/v5/tutorials/topical/imu.html to learn
 * more.
 *
 * This file should not be modified by users, since it gets replaced whenever
 * a kernel upgrade occurs.
 *
 * \copyright Copyright (c) 2017-2023, Purdue University ACM SIGBots.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */ 1 1 17 4 18446744073709551615 1 # 18 1 18 2 18446744073709551615 6 ifndef 18 2 18 8 18446744073709551615 14 _PROS_IMU_HPP_ 18 9 18 23 18446744073709551615 1 # 19 1 19 2 18446744073709551615 6 define 19 2 19 8 18446744073709551615 14 _PROS_IMU_HPP_ 19 9 19 23 18446744073709551615 1 # 21 1 21 2 18446744073709551615 7 include 21 2 21 9 18446744073709551615 1 < 21 10 21 11 18446744073709551615 7 cstdint 21 11 21 18 18446744073709551615 1 > 21 18 21 19 18446744073709551615 1 # 22 1 22 2 18446744073709551615 7 include 22 2 22 9 18446744073709551615 12 "pros/imu.h" 22 10 22 22 18446744073709551615 9 namespace 24 1 24 10 18446744073709551615 4 pros 24 11 24 15 0 1 { 24 16 24 17 18446744073709551615 5 class 25 1 25 6 18446744073709551615 3 Imu 25 7 25 10 1 1 { 25 11 25 12 18446744073709551615 5 const 26 2 26 7 18446744073709551615 3 std 26 8 26 11 2 2 :: 26 11 26 13 18446744073709551615 7 uint8_t 26 13 26 20 3 5 _port 26 21 26 26 3 1 ; 26 26 26 27 18446744073709551615 6 public 28 2 28 8 18446744073709551615 1 : 28 8 28 9 18446744073709551615 3 Imu 29 2 29 5 1 1 ( 29 5 29 6 1 5 const 29 6 29 11 18446744073709551615 3 std 29 12 29 15 2 2 :: 29 15 29 17 18446744073709551615 7 uint8_t 29 17 29 24 4 4 port 29 25 29 29 4 1 ) 29 29 29 30 1 1 : 29 31 29 32 1 5 _port 29 33 29 38 3 1 ( 29 38 29 39 1 4 port 29 39 29 43 4 1 ) 29 43 29 44 1 1 { 29 44 29 45 18446744073709551615 1 } 29 45 29 46 18446744073709551615 1 ; 29 46 29 47 18446744073709551615 909 /**
	 * Calibrate IMU
	 *
	 * Calibration takes approximately 2 seconds and blocks during this period if 
	 * the blocking param is true, with a timeout for this operation being set a 3 
	 * seconds as a safety margin. This function also blocks until the IMU 
	 * status flag is set properly to E_IMU_STATUS_CALIBRATING, with a minimum 
	 * blocking time of 5ms and a timeout of 1 second if it's never set.
	 * 
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is already calibrating, or time out setting the status flag.
	 *
	 * \param blocking 
	 *			Whether this function blocks during calibration.
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 31 2 50 5 18446744073709551615 7 virtual 51 2 51 9 18446744073709551615 3 std 51 10 51 13 2 2 :: 51 13 51 15 5 7 int32_t 51 15 51 22 5 5 reset 51 23 51 28 5 1 ( 51 28 51 29 5 4 bool 51 29 51 33 18446744073709551615 8 blocking 51 34 51 42 6 1 = 51 43 51 44 18446744073709551615 5 false 51 45 51 50 18446744073709551615 1 ) 51 50 51 51 5 5 const 51 52 51 57 18446744073709551615 1 ; 51 57 51 58 18446744073709551615 943 /**
	* Set the Inertial Sensor's refresh interval in milliseconds.
	*
	* The rate may be specified in increments of 5ms, and will be rounded down to
	* the nearest increment. The minimum allowable refresh rate is 5ms. The default
	* rate is 10ms.
	*
	* As values are copied into the shared memory buffer only at 10ms intervals,
	* setting this value to less than 10ms does not mean that you can poll the
	* sensor's values any faster. However, it will guarantee that the data is as
	* recent as possible.
	*
	* This function uses the following values of errno when an error state is
	* reached:
	* ENXIO - The given value is not within the range of V5 ports (1-21).
	* ENODEV - The port cannot be configured as an Inertial Sensor
	* EAGAIN - The sensor is still calibrating
	*
	* \param rate 
	*			The data refresh interval in milliseconds
	* \return 1 if the operation was successful or PROS_ERR if the operation
	* failed, setting errno.
	*/ 52 2 74 4 18446744073709551615 7 virtual 75 2 75 9 18446744073709551615 3 std 75 10 75 13 2 2 :: 75 13 75 15 7 7 int32_t 75 15 75 22 7 13 set_data_rate 75 23 75 36 7 1 ( 75 36 75 37 7 3 std 75 37 75 40 2 2 :: 75 40 75 42 18446744073709551615 8 uint32_t 75 42 75 50 8 4 rate 75 51 75 55 8 1 ) 75 55 75 56 7 5 const 75 57 75 62 18446744073709551615 1 ; 75 62 75 63 18446744073709551615 716 /**
	 * Get the total number of degrees the Inertial Sensor has spun about the z-axis
	 *
	 * This value is theoretically unbounded. Clockwise rotations are represented
	 * with positive degree values, while counterclockwise rotations are represented
	 * with negative ones.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is still calibrating
	 *
	 * \param  port
	 * 				 The V5 Inertial Sensor port number from 1-21
	 * \return The degree value or PROS_ERR_F if the operation failed, setting
	 * errno.
	 */ 76 2 93 5 18446744073709551615 7 virtual 94 2 94 9 18446744073709551615 6 double 94 10 94 16 18446744073709551615 12 get_rotation 94 17 94 29 9 1 ( 94 29 94 30 9 1 ) 94 30 94 31 9 5 const 94 32 94 37 18446744073709551615 1 ; 94 37 94 38 18446744073709551615 719 /**
	 * Get the Inertial Sensor's heading relative to the initial direction of its
	 * x-axis
	 *
	 * This value is bounded by [0,360). Clockwise rotations are represented with
	 * positive degree values, while counterclockwise rotations are represented with
	 * negative ones.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is still calibrating
	 *
	 * \param  port
	 * 				 The V5 Inertial Sensor port number from 1-21
	 * \return The degree value or PROS_ERR_F if the operation failed, setting
	 * errno.
	 */ 95 2 113 5 18446744073709551615 7 virtual 114 2 114 9 18446744073709551615 6 double 114 10 114 16 18446744073709551615 11 get_heading 114 17 114 28 10 1 ( 114 28 114 29 10 1 ) 114 29 114 30 10 5 const 114 31 114 36 18446744073709551615 1 ; 114 36 114 37 18446744073709551615 599 /**
	 * Get a quaternion representing the Inertial Sensor's orientation
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is still calibrating
	 *
	 * \param  port
	 * 				 The V5 Inertial Sensor port number from 1-21
	 * \return The quaternion representing the sensor's orientation. If the
	 * operation failed, all the quaternion's members are filled with PROS_ERR_F and
	 * errno is set.
	 */ 115 2 129 5 18446744073709551615 7 virtual 130 2 130 9 18446744073709551615 4 pros 130 10 130 14 0 2 :: 130 14 130 16 11 1 c 130 16 130 17 12 2 :: 130 17 130 19 11 14 quaternion_s_t 130 19 130 33 13 14 get_quaternion 130 34 130 48 11 1 ( 130 48 130 49 11 1 ) 130 49 130 50 11 5 const 130 51 130 56 18446744073709551615 1 ; 130 56 130 57 18446744073709551615 604 /**
	 * Get the Euler angles representing the Inertial Sensor's orientation
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is still calibrating
	 *
	 * \param  port
	 * 				 The V5 Inertial Sensor port number from 1-21
	 * \return The Euler angles representing the sensor's orientation. If the
	 * operation failed, all the structure's members are filled with PROS_ERR_F and
	 * errno is set.
	 */ 131 2 145 5 18446744073709551615 7 virtual 146 2 146 9 18446744073709551615 4 pros 146 10 146 14 0 2 :: 146 14 146 16 14 1 c 146 16 146 17 12 2 :: 146 17 146 19 14 9 euler_s_t 146 19 146 28 15 9 get_euler 146 29 146 38 14 1 ( 146 38 146 39 14 1 ) 146 39 146 40 14 5 const 146 41 146 46 18446744073709551615 1 ; 146 46 146 47 18446744073709551615 509 /**
	 * Get the Inertial Sensor's pitch angle bounded by (-180,180)
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is still calibrating
	 *
	 * \param  port
	 * 				 The V5 Inertial Sensor port number from 1-21
	 * \return The pitch angle, or PROS_ERR_F if the operation failed, setting
	 * errno.
	 */ 147 2 160 5 18446744073709551615 7 virtual 161 2 161 9 18446744073709551615 6 double 161 10 161 16 18446744073709551615 9 get_pitch 161 17 161 26 16 1 ( 161 26 161 27 16 1 ) 161 27 161 28 16 5 const 161 29 161 34 18446744073709551615 1 ; 161 34 161 35 18446744073709551615 503 /**
	 * Get the Inertial Sensor's roll angle bounded by (-180,180)
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is still calibrating
	 *
	 * \param  port
	 * 				 The V5 Inertial Sensor port number from 1-21
	 * \return The roll angle, or PROS_ERR_F if the operation failed, setting errno.
	 */ 162 2 174 5 18446744073709551615 7 virtual 175 2 175 9 18446744073709551615 6 double 175 10 175 16 18446744073709551615 8 get_roll 175 17 175 25 17 1 ( 175 25 175 26 17 1 ) 175 26 175 27 17 5 const 175 28 175 33 18446744073709551615 1 ; 175 33 175 34 18446744073709551615 501 /**
	 * Get the Inertial Sensor's yaw angle bounded by (-180,180)
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is still calibrating
	 *
	 * \param  port
	 * 				 The V5 Inertial Sensor port number from 1-21
	 * \return The yaw angle, or PROS_ERR_F if the operation failed, setting errno.
	 */ 176 2 188 5 18446744073709551615 7 virtual 189 2 189 9 18446744073709551615 6 double 189 10 189 16 18446744073709551615 7 get_yaw 189 17 189 24 18 1 ( 189 24 189 25 18 1 ) 189 25 189 26 18 5 const 189 27 189 32 18446744073709551615 1 ; 189 32 189 33 18446744073709551615 549 /**
	 * Get the Inertial Sensor's raw gyroscope values
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is still calibrating
	 *
	 * \param  port
	 * 				 The V5 Inertial Sensor port number from 1-21
	 * \return The raw gyroscope values. If the operation failed, all the
	 * structure's members are filled with PROS_ERR_F and errno is set.
	 */ 190 2 203 5 18446744073709551615 7 virtual 204 2 204 9 18446744073709551615 4 pros 204 10 204 14 0 2 :: 204 14 204 16 19 1 c 204 16 204 17 12 2 :: 204 17 204 19 19 12 imu_gyro_s_t 204 19 204 31 20 13 get_gyro_rate 204 32 204 45 19 1 ( 204 45 204 46 19 1 ) 204 46 204 47 19 5 const 204 48 204 53 18446744073709551615 1 ; 204 53 204 54 18446744073709551615 533 /**
	 * Resets the current reading of the Inertial Sensor's rotation to zero
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is still calibrating
	 *
	 * \param  port
	 * 				 The V5 Inertial Sensor port number from 1-21
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 205 2 218 5 18446744073709551615 7 virtual 219 2 219 9 18446744073709551615 3 std 219 10 219 13 2 2 :: 219 13 219 15 21 7 int32_t 219 15 219 22 21 13 tare_rotation 219 23 219 36 21 1 ( 219 36 219 37 21 1 ) 219 37 219 38 21 5 const 219 39 219 44 18446744073709551615 1 ; 219 44 219 45 18446744073709551615 532 /**
	 * Resets the current reading of the Inertial Sensor's heading to zero
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is still calibrating
	 *
	 * \param  port
	 * 				 The V5 Inertial Sensor port number from 1-21
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 220 2 233 5 18446744073709551615 7 virtual 234 2 234 9 18446744073709551615 3 std 234 10 234 13 2 2 :: 234 13 234 15 22 7 int32_t 234 15 234 22 22 12 tare_heading 234 23 234 35 22 1 ( 234 35 234 36 22 1 ) 234 36 234 37 22 5 const 234 38 234 43 18446744073709551615 1 ; 234 43 234 44 18446744073709551615 530 /**
	 * Resets the current reading of the Inertial Sensor's pitch to zero
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is still calibrating
	 *
	 * \param  port
	 * 				 The V5 Inertial Sensor port number from 1-21
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 235 2 248 5 18446744073709551615 7 virtual 249 2 249 9 18446744073709551615 3 std 249 10 249 13 2 2 :: 249 13 249 15 23 7 int32_t 249 15 249 22 23 10 tare_pitch 249 23 249 33 23 1 ( 249 33 249 34 23 1 ) 249 34 249 35 23 5 const 249 36 249 41 18446744073709551615 1 ; 249 41 249 42 18446744073709551615 528 /**
	 * Resets the current reading of the Inertial Sensor's yaw to zero
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is still calibrating
	 *
	 * \param  port
	 * 				 The V5 Inertial Sensor port number from 1-21
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 250 2 263 5 18446744073709551615 7 virtual 264 2 264 9 18446744073709551615 3 std 264 10 264 13 2 2 :: 264 13 264 15 24 7 int32_t 264 15 264 22 24 8 tare_yaw 264 23 264 31 24 1 ( 264 31 264 32 24 1 ) 264 32 264 33 24 5 const 264 34 264 39 18446744073709551615 1 ; 264 39 264 40 18446744073709551615 529 /**
	 * Resets the current reading of the Inertial Sensor's roll to zero
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is still calibrating
	 *
	 * \param  port
	 * 				 The V5 Inertial Sensor port number from 1-21
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 265 2 278 5 18446744073709551615 7 virtual 279 2 279 9 18446744073709551615 3 std 279 10 279 13 2 2 :: 279 13 279 15 25 7 int32_t 279 15 279 22 25 9 tare_roll 279 23 279 32 25 1 ( 279 32 279 33 25 1 ) 279 33 279 34 25 5 const 279 35 279 40 18446744073709551615 1 ; 279 40 279 41 18446744073709551615 513 /**
	 * Resets all 5 values of the Inertial Sensor to 0.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is still calibrating
	 *
	 * \param  port
	 * 				 The V5 Inertial Sensor port number from 1-21
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 280 2 293 5 18446744073709551615 7 virtual 294 2 294 9 18446744073709551615 3 std 294 10 294 13 2 2 :: 294 13 294 15 26 7 int32_t 294 15 294 22 26 4 tare 294 23 294 27 26 1 ( 294 27 294 28 26 1 ) 294 28 294 29 26 5 const 294 30 294 35 18446744073709551615 1 ; 294 35 294 36 18446744073709551615 518 /**
	 * Reset all 3 euler values of the Inertial Sensor to 0.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is still calibrating
	 *
	 * \param  port
	 * 				 The V5 Inertial Sensor port number from 1-21
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 295 2 308 5 18446744073709551615 7 virtual 309 2 309 9 18446744073709551615 3 std 309 10 309 13 2 2 :: 309 13 309 15 27 7 int32_t 309 15 309 22 27 10 tare_euler 309 23 309 33 27 1 ( 309 33 309 34 27 1 ) 309 34 309 35 27 5 const 309 36 309 41 18446744073709551615 1 ; 309 41 309 42 18446744073709551615 688 /**
	 * Sets the current reading of the Inertial Sensor's heading to target value
	 * Target will default to 360 if above 360 and default to 0 if below 0.
	 * 
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is still calibrating
	 *
	 * \param  port
	 * 				 The V5 Inertial Sensor port number from 1-21
	 * \param  target
	 * 				 Target value for the heading value to be set to
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 310 2 326 5 18446744073709551615 7 virtual 327 2 327 9 18446744073709551615 3 std 327 10 327 13 2 2 :: 327 13 327 15 28 7 int32_t 327 15 327 22 28 11 set_heading 327 23 327 34 28 1 ( 327 34 327 35 28 5 const 327 35 327 40 18446744073709551615 6 double 327 41 327 47 18446744073709551615 6 target 327 48 327 54 29 1 ) 327 54 327 55 28 5 const 327 56 327 61 18446744073709551615 1 ; 327 61 327 62 18446744073709551615 616 /**
	 * Sets the current reading of the Inertial Sensor's rotation to target value
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is still calibrating
	 *
	 * \param  port
	 * 				 The V5 Inertial Sensor port number from 1-21
	 * \param  target
	 * 				 Target value for the rotation value to be set to
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 328 2 343 5 18446744073709551615 7 virtual 344 2 344 9 18446744073709551615 3 std 344 10 344 13 2 2 :: 344 13 344 15 30 7 int32_t 344 15 344 22 30 12 set_rotation 344 23 344 35 30 1 ( 344 35 344 36 30 5 const 344 36 344 41 18446744073709551615 6 double 344 42 344 48 18446744073709551615 6 target 344 49 344 55 31 1 ) 344 55 344 56 30 5 const 344 57 344 62 18446744073709551615 1 ; 344 62 344 63 18446744073709551615 658 /**
	 * Sets the current reading of the Inertial Sensor's yaw to target value
	 * Will default to +/- 180 if target exceeds +/- 180.
	 * 
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is still calibrating
	 *
	 * \param  port
	 * 				 The V5 Inertial Sensor port number from 1-21
	 * \param  target
	 * 				 Target value for yaw value to be set to
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 345 2 361 5 18446744073709551615 7 virtual 362 2 362 9 18446744073709551615 3 std 362 10 362 13 2 2 :: 362 13 362 15 32 7 int32_t 362 15 362 22 32 7 set_yaw 362 23 362 30 32 1 ( 362 30 362 31 32 5 const 362 31 362 36 18446744073709551615 6 double 362 37 362 43 18446744073709551615 6 target 362 44 362 50 33 1 ) 362 50 362 51 32 5 const 362 52 362 57 18446744073709551615 1 ; 362 57 362 58 18446744073709551615 610 /**
	 * Sets the current reading of the Inertial Sensor's pitch to target value
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is still calibrating
	 *
	 * \param  port
	 * 				 The V5 Inertial Sensor port number from 1-21
	 * \param  target
	 * 				 Target value for the pitch value to be set to
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 363 2 378 5 18446744073709551615 7 virtual 379 2 379 9 18446744073709551615 3 std 379 10 379 13 2 2 :: 379 13 379 15 34 7 int32_t 379 15 379 22 34 9 set_pitch 379 23 379 32 34 1 ( 379 32 379 33 34 5 const 379 33 379 38 18446744073709551615 6 double 379 39 379 45 18446744073709551615 6 target 379 46 379 52 35 1 ) 379 52 379 53 34 5 const 379 54 379 59 18446744073709551615 1 ; 379 59 379 60 18446744073709551615 673 /**
	 * Sets the current reading of the Inertial Sensor's roll to target value
	 * Will default to +/- 180 if target exceeds +/- 180.
	 * 
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is still calibrating
	 *
	 * \param  port
	 * 				 The V5 Inertial Sensor port number from 1-21
	 * \param  target
	 * 				 Target euler values for the euler values to be set to
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 380 2 396 5 18446744073709551615 7 virtual 397 2 397 9 18446744073709551615 3 std 397 10 397 13 2 2 :: 397 13 397 15 36 7 int32_t 397 15 397 22 36 8 set_roll 397 23 397 31 36 1 ( 397 31 397 32 36 5 const 397 32 397 37 18446744073709551615 6 double 397 38 397 44 18446744073709551615 6 target 397 45 397 51 37 1 ) 397 51 397 52 36 5 const 397 53 397 58 18446744073709551615 1 ; 397 58 397 59 18446744073709551615 688 /**
	 * Sets the current reading of the Inertial Sensor's euler values to
	 * target euler values. Will default to +/- 180 if target exceeds +/- 180.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is still calibrating
	 *
	 * \param  port
	 * 				 The V5 Inertial Sensor port number from 1-21
	 * \param  target
	 * 				 Target euler values for the euler values to be set to
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 398 2 414 5 18446744073709551615 7 virtual 415 2 415 9 18446744073709551615 3 std 415 10 415 13 2 2 :: 415 13 415 15 38 7 int32_t 415 15 415 22 38 9 set_euler 415 23 415 32 38 1 ( 415 32 415 33 38 5 const 415 33 415 38 18446744073709551615 4 pros 415 39 415 43 0 2 :: 415 43 415 45 18446744073709551615 1 c 415 45 415 46 12 2 :: 415 46 415 48 18446744073709551615 9 euler_s_t 415 48 415 57 15 6 target 415 58 415 64 39 1 ) 415 64 415 65 38 5 const 415 66 415 71 18446744073709551615 1 ; 415 71 415 72 18446744073709551615 557 /**
	 * Get the Inertial Sensor's raw accelerometer values
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is still calibrating
	 *
	 * \param  port
	 * 				 The V5 Inertial Sensor port number from 1-21
	 * \return The raw accelerometer values. If the operation failed, all the
	 * structure's members are filled with PROS_ERR_F and errno is set.
	 */ 416 2 429 5 18446744073709551615 7 virtual 430 2 430 9 18446744073709551615 4 pros 430 10 430 14 0 2 :: 430 14 430 16 40 1 c 430 16 430 17 12 2 :: 430 17 430 19 40 13 imu_accel_s_t 430 19 430 32 41 9 get_accel 430 33 430 42 40 1 ( 430 42 430 43 40 1 ) 430 43 430 44 40 5 const 430 45 430 50 18446744073709551615 1 ; 430 50 430 51 18446744073709551615 498 /**
	 * Get the Inertial Sensor's status
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as an Inertial Sensor
	 * EAGAIN - The sensor is still calibrating
	 *
	 * \param  port
	 * 				 The V5 Inertial Sensor port number from 1-21
	 * \return The Inertial Sensor's status code, or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 431 2 444 5 18446744073709551615 7 virtual 445 2 445 9 18446744073709551615 4 pros 445 10 445 14 0 2 :: 445 14 445 16 42 1 c 445 16 445 17 12 2 :: 445 17 445 19 42 14 imu_status_e_t 445 19 445 33 43 10 get_status 445 34 445 44 42 1 ( 445 44 445 45 42 1 ) 445 45 445 46 42 5 const 445 47 445 52 18446744073709551615 1 ; 445 52 445 53 18446744073709551615 144 /**
	 * Check whether the IMU is calibrating
	 *
	 * \return true if the V5 Inertial Sensor is calibrating or false
	 * false if it is not.
	 */ 446 2 451 5 18446744073709551615 7 virtual 452 2 452 9 18446744073709551615 4 bool 452 10 452 14 18446744073709551615 14 is_calibrating 452 15 452 29 44 1 ( 452 29 452 30 44 1 ) 452 30 452 31 44 5 const 452 32 452 37 18446744073709551615 1 ; 452 37 452 38 18446744073709551615 1 } 453 1 453 2 18446744073709551615 1 ; 453 2 453 3 18446744073709551615 5 using 455 1 455 6 18446744073709551615 3 IMU 455 7 455 10 45 1 = 455 11 455 12 18446744073709551615 3 Imu 455 13 455 16 1 1 ; 455 16 455 17 18446744073709551615 1 } 457 1 457 2 18446744073709551615 17 // namespace pros 457 4 457 21 18446744073709551615 1 # 459 1 459 2 18446744073709551615 5 endif 459 2 459 7 18446744073709551615 0 0 46 0 0 0 22 0 0 1 13 0 4 pros 4 1 13 0 8 Imu:pros 22 1 13 0 3 std 6 1 13 0 14 _port:Imu:pros 10 1 13 0 67 29:25:/home/bluecore/Desktop/Pros/Main Project/include/pros/imu.hpp 21 1 13 0 14 reset:Imu:pros 10 1 13 0 67 51:34:/home/bluecore/Desktop/Pros/Main Project/include/pros/imu.hpp 21 1 13 0 22 set_data_rate:Imu:pros 10 1 13 0 67 75:51:/home/bluecore/Desktop/Pros/Main Project/include/pros/imu.hpp 21 1 13 0 21 get_rotation:Imu:pros 21 1 13 0 20 get_heading:Imu:pros 21 1 13 0 23 get_quaternion:Imu:pros 22 1 13 0 6 c:pros 20 1 13 0 21 quaternion_s_t:c:pros 21 1 13 0 18 get_euler:Imu:pros 20 1 13 0 16 euler_s_t:c:pros 21 1 13 0 18 get_pitch:Imu:pros 21 1 13 0 17 get_roll:Imu:pros 21 1 13 0 16 get_yaw:Imu:pros 21 1 13 0 22 get_gyro_rate:Imu:pros 20 1 13 0 19 imu_gyro_s_t:c:pros 21 1 13 0 22 tare_rotation:Imu:pros 21 1 13 0 21 tare_heading:Imu:pros 21 1 13 0 19 tare_pitch:Imu:pros 21 1 13 0 17 tare_yaw:Imu:pros 21 1 13 0 18 tare_roll:Imu:pros 21 1 13 0 13 tare:Imu:pros 21 1 13 0 19 tare_euler:Imu:pros 21 1 13 0 20 set_heading:Imu:pros 10 1 13 0 68 327:48:/home/bluecore/Desktop/Pros/Main Project/include/pros/imu.hpp 21 1 13 0 21 set_rotation:Imu:pros 10 1 13 0 68 344:49:/home/bluecore/Desktop/Pros/Main Project/include/pros/imu.hpp 21 1 13 0 16 set_yaw:Imu:pros 10 1 13 0 68 362:44:/home/bluecore/Desktop/Pros/Main Project/include/pros/imu.hpp 21 1 13 0 18 set_pitch:Imu:pros 10 1 13 0 68 379:46:/home/bluecore/Desktop/Pros/Main Project/include/pros/imu.hpp 21 1 13 0 17 set_roll:Imu:pros 10 1 13 0 68 397:45:/home/bluecore/Desktop/Pros/Main Project/include/pros/imu.hpp 21 1 13 0 18 set_euler:Imu:pros 10 1 13 0 68 415:58:/home/bluecore/Desktop/Pros/Main Project/include/pros/imu.hpp 21 1 13 0 18 get_accel:Imu:pros 20 1 13 0 20 imu_accel_s_t:c:pros 21 1 13 0 19 get_status:Imu:pros 20 1 13 0 21 imu_status_e_t:c:pros 21 1 13 0 23 is_calibrating:Imu:pros 36 1 13 0 8 IMU:pros 0 0 1 0 0 0 61 /home/bluecore/Desktop/Pros/Main Project/include/pros/imu.hpp 1698321176