22 serialization::archive 19 0 0 0 0 40 /home/bluecore/Desktop/Pros/Main Project 40 /home/bluecore/Desktop/Pros/Main Project 0 0 1415 0 0 0 561 /**
 * \file pros/motors.hpp
 *
 * Contains prototypes for the V5 Motor-related functions.
 *
 * Visit https://pros.cs.purdue.edu/v5/tutorials/topical/motors.html to learn
 * more.
 *
 * This file should not be modified by users, since it gets replaced whenever
 * a kernel upgrade occurs.
 *
 * \copyright (c) 2017-2021, Purdue University ACM SIGBots.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */ 1 1 17 4 18446744073709551615 1 # 19 1 19 2 18446744073709551615 6 ifndef 19 2 19 8 18446744073709551615 17 _PROS_MOTORS_HPP_ 19 9 19 26 18446744073709551615 1 # 20 1 20 2 18446744073709551615 6 define 20 2 20 8 18446744073709551615 17 _PROS_MOTORS_HPP_ 20 9 20 26 18446744073709551615 1 # 22 1 22 2 18446744073709551615 7 include 22 2 22 9 18446744073709551615 1 < 22 10 22 11 18446744073709551615 7 cstdint 22 11 22 18 18446744073709551615 1 > 22 18 22 19 18446744073709551615 1 # 23 1 23 2 18446744073709551615 7 include 23 2 23 9 18446744073709551615 1 < 23 10 23 11 18446744073709551615 16 initializer_list 23 11 23 27 18446744073709551615 1 > 23 27 23 28 18446744073709551615 1 # 24 1 24 2 18446744073709551615 7 include 24 2 24 9 18446744073709551615 1 < 24 10 24 11 18446744073709551615 6 vector 24 11 24 17 18446744073709551615 1 > 24 17 24 18 18446744073709551615 1 # 26 1 26 2 18446744073709551615 7 include 26 2 26 9 18446744073709551615 15 "pros/motors.h" 26 10 26 25 18446744073709551615 1 # 27 1 27 2 18446744073709551615 7 include 27 2 27 9 18446744073709551615 15 "pros/rtos.hpp" 27 10 27 25 18446744073709551615 9 namespace 29 1 29 10 18446744073709551615 4 pros 29 11 29 15 0 1 { 29 16 29 17 18446744073709551615 5 class 30 1 30 6 18446744073709551615 5 Motor 30 7 30 12 1 1 { 30 13 30 14 18446744073709551615 6 public 31 2 31 8 18446744073709551615 1 : 31 8 31 9 18446744073709551615 537 /**
	 * Creates a Motor object for the given port and specifications.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - The given value is not within the range of V5 ports (1-21).
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \param port
	 *        The V5 port number from 1-21
	 * \param gearset
	 *        The motor's gearset
	 * \param reverse
	 *        True reverses the motor, false is default
	 * \param encoder_units
	 *        The motor's encoder units
	 */ 32 2 48 5 18446744073709551615 8 explicit 49 2 49 10 18446744073709551615 5 Motor 49 11 49 16 1 1 ( 49 16 49 17 1 5 const 49 17 49 22 18446744073709551615 3 std 49 23 49 26 2 2 :: 49 26 49 28 18446744073709551615 6 int8_t 49 28 49 34 3 4 port 49 35 49 39 3 1 , 49 39 49 40 1 5 const 49 41 49 46 18446744073709551615 17 motor_gearset_e_t 49 47 49 64 4 7 gearset 49 65 49 72 5 1 , 49 72 49 73 1 5 const 49 74 49 79 18446744073709551615 4 bool 49 80 49 84 18446744073709551615 7 reverse 49 85 49 92 6 1 , 49 92 49 93 1 5 const 50 17 50 22 18446744073709551615 23 motor_encoder_units_e_t 50 23 50 46 7 13 encoder_units 50 47 50 60 8 1 ) 50 60 50 61 1 1 ; 50 61 50 62 18446744073709551615 8 explicit 52 2 52 10 18446744073709551615 5 Motor 52 11 52 16 1 1 ( 52 16 52 17 1 5 const 52 17 52 22 18446744073709551615 3 std 52 23 52 26 2 2 :: 52 26 52 28 18446744073709551615 6 int8_t 52 28 52 34 9 4 port 52 35 52 39 9 1 , 52 39 52 40 1 5 const 52 41 52 46 18446744073709551615 17 motor_gearset_e_t 52 47 52 64 4 7 gearset 52 65 52 72 10 1 , 52 72 52 73 1 5 const 52 74 52 79 18446744073709551615 4 bool 52 80 52 84 18446744073709551615 7 reverse 52 85 52 92 11 1 ) 52 92 52 93 1 1 ; 52 93 52 94 18446744073709551615 8 explicit 54 2 54 10 18446744073709551615 5 Motor 54 11 54 16 1 1 ( 54 16 54 17 1 5 const 54 17 54 22 18446744073709551615 3 std 54 23 54 26 2 2 :: 54 26 54 28 18446744073709551615 6 int8_t 54 28 54 34 12 4 port 54 35 54 39 12 1 , 54 39 54 40 1 5 const 54 41 54 46 18446744073709551615 17 motor_gearset_e_t 54 47 54 64 4 7 gearset 54 65 54 72 13 1 ) 54 72 54 73 1 1 ; 54 73 54 74 18446744073709551615 8 explicit 56 2 56 10 18446744073709551615 5 Motor 56 11 56 16 1 1 ( 56 16 56 17 1 5 const 56 17 56 22 18446744073709551615 3 std 56 23 56 26 2 2 :: 56 26 56 28 18446744073709551615 6 int8_t 56 28 56 34 14 4 port 56 35 56 39 14 1 , 56 39 56 40 1 5 const 56 41 56 46 18446744073709551615 4 bool 56 47 56 51 18446744073709551615 7 reverse 56 52 56 59 15 1 ) 56 59 56 60 1 1 ; 56 60 56 61 18446744073709551615 8 explicit 58 2 58 10 18446744073709551615 5 Motor 58 11 58 16 1 1 ( 58 16 58 17 1 5 const 58 17 58 22 18446744073709551615 3 std 58 23 58 26 2 2 :: 58 26 58 28 18446744073709551615 6 int8_t 58 28 58 34 16 4 port 58 35 58 39 16 1 ) 58 39 58 40 1 1 ; 58 40 58 41 18446744073709551615 78 /****************************************************************************/ 60 2 60 80 18446744073709551615 78 /**                         Motor movement functions                       **/ 61 2 61 80 18446744073709551615 78 /**                                                                        **/ 62 2 62 80 18446744073709551615 78 /**          These functions allow programmers to make motors move         **/ 63 2 63 80 18446744073709551615 78 /****************************************************************************/ 64 2 64 80 18446744073709551615 618 /**
	 * Sets the voltage for the motor from -128 to 127.
	 *
	 * This is designed to map easily to the input from the controller's analog
	 * stick for simple opcontrol use. The actual behavior of the motor is
	 * analogous to use of pros::Motor::move(), or motorSet from the PROS 2 API.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \param voltage
	 *        The new motor voltage from -127 to 127
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 65 2 81 5 18446744073709551615 7 virtual 82 2 82 9 18446744073709551615 3 std 82 10 82 13 2 2 :: 82 13 82 15 17 7 int32_t 82 15 82 22 17 8 operator 82 23 82 31 17 1 = 82 31 82 32 17 1 ( 82 32 82 33 17 3 std 82 33 82 36 2 2 :: 82 36 82 38 18446744073709551615 7 int32_t 82 38 82 45 18 7 voltage 82 46 82 53 18 1 ) 82 53 82 54 17 5 const 82 55 82 60 18446744073709551615 1 ; 82 60 82 61 18446744073709551615 613 /**
	 * Sets the voltage for the motor from -127 to 127.
	 *
	 * This is designed to map easily to the input from the controller's analog
	 * stick for simple opcontrol use. The actual behavior of the motor is
	 * analogous to use of motor_move(), or motorSet() from the PROS 2 API.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \param voltage
	 *        The new motor voltage from -127 to 127
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 84 2 100 5 18446744073709551615 7 virtual 101 2 101 9 18446744073709551615 3 std 101 10 101 13 2 2 :: 101 13 101 15 19 7 int32_t 101 15 101 22 19 4 move 101 23 101 27 19 1 ( 101 27 101 28 19 3 std 101 28 101 31 2 2 :: 101 31 101 33 18446744073709551615 7 int32_t 101 33 101 40 20 7 voltage 101 41 101 48 20 1 ) 101 48 101 49 19 5 const 101 50 101 55 18446744073709551615 1 ; 101 55 101 56 18446744073709551615 818 /**
	 * Sets the target absolute position for the motor to move to.
	 *
	 * This movement is relative to the position of the motor when initialized or
	 * the position when it was most recently reset with
	 * pros::Motor::set_zero_position().
	 *
	 * \note This function simply sets the target for the motor, it does not block
	 * program execution until the movement finishes.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \param position
	 *        The absolute position to move to in the motor's encoder units
	 * \param velocity
	 *        The maximum allowable velocity for the movement in RPM
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 103 2 124 5 18446744073709551615 7 virtual 125 2 125 9 18446744073709551615 3 std 125 10 125 13 2 2 :: 125 13 125 15 21 7 int32_t 125 15 125 22 21 13 move_absolute 125 23 125 36 21 1 ( 125 36 125 37 21 5 const 125 37 125 42 18446744073709551615 6 double 125 43 125 49 18446744073709551615 8 position 125 50 125 58 22 1 , 125 58 125 59 21 5 const 125 60 125 65 18446744073709551615 3 std 125 66 125 69 2 2 :: 125 69 125 71 18446744073709551615 7 int32_t 125 71 125 78 23 8 velocity 125 79 125 87 23 1 ) 125 87 125 88 21 5 const 125 89 125 94 18446744073709551615 1 ; 125 94 125 95 18446744073709551615 907 /**
	 * Sets the relative target position for the motor to move to.
	 *
	 * This movement is relative to the current position of the motor as given in
	 * pros::Motor::motor_get_position(). Providing 10.0 as the position parameter
	 * would result in the motor moving clockwise 10 units, no matter what the
	 * current position is.
	 *
	 * \note This function simply sets the target for the motor, it does not block
	 * program execution until the movement finishes.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \param position
	 *        The relative position to move to in the motor's encoder units
	 * \param velocity
	 *        The maximum allowable velocity for the movement in RPM
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 127 2 149 5 18446744073709551615 7 virtual 150 2 150 9 18446744073709551615 3 std 150 10 150 13 2 2 :: 150 13 150 15 24 7 int32_t 150 15 150 22 24 13 move_relative 150 23 150 36 24 1 ( 150 36 150 37 24 5 const 150 37 150 42 18446744073709551615 6 double 150 43 150 49 18446744073709551615 8 position 150 50 150 58 25 1 , 150 58 150 59 24 5 const 150 60 150 65 18446744073709551615 3 std 150 66 150 69 2 2 :: 150 69 150 71 18446744073709551615 7 int32_t 150 71 150 78 26 8 velocity 150 79 150 87 26 1 ) 150 87 150 88 24 5 const 150 89 150 94 18446744073709551615 1 ; 150 94 150 95 18446744073709551615 772 /**
	 * Sets the velocity for the motor.
	 *
	 * This velocity corresponds to different actual speeds depending on the
	 * gearset used for the motor. This results in a range of +-100 for
	 * E_MOTOR_GEARSET_36, +-200 for E_MOTOR_GEARSET_18, and +-600 for
	 * E_MOTOR_GEARSET_6. The velocity is held with PID to ensure consistent
	 * speed, as opposed to setting the motor's voltage.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \param velocity
	 *        The new motor velocity from -+-100, +-200, or +-600 depending on the
	 *        motor's gearset
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 152 2 171 5 18446744073709551615 7 virtual 172 2 172 9 18446744073709551615 3 std 172 10 172 13 2 2 :: 172 13 172 15 27 7 int32_t 172 15 172 22 27 13 move_velocity 172 23 172 36 27 1 ( 172 36 172 37 27 5 const 172 37 172 42 18446744073709551615 3 std 172 43 172 46 2 2 :: 172 46 172 48 18446744073709551615 7 int32_t 172 48 172 55 28 8 velocity 172 56 172 64 28 1 ) 172 64 172 65 27 5 const 172 66 172 71 18446744073709551615 1 ; 172 71 172 72 18446744073709551615 416 /**
	 * Sets the output voltage for the motor from -12000 to 12000 in millivolts.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \param voltage
	 *        The new voltage value from -12000 to 12000
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 174 2 186 5 18446744073709551615 7 virtual 187 2 187 9 18446744073709551615 3 std 187 10 187 13 2 2 :: 187 13 187 15 29 7 int32_t 187 15 187 22 29 12 move_voltage 187 23 187 35 29 1 ( 187 35 187 36 29 5 const 187 36 187 41 18446744073709551615 3 std 187 42 187 45 2 2 :: 187 45 187 47 18446744073709551615 7 int32_t 187 47 187 54 30 7 voltage 187 55 187 62 30 1 ) 187 62 187 63 29 5 const 187 64 187 69 18446744073709551615 1 ; 187 69 187 70 18446744073709551615 577 /**
	 * Stops the motor using the currently configured brake mode.
	 *
	 * This function sets motor velocity to zero, which will cause it to act
	 * according to the set brake mode. If brake mode is set to MOTOR_BRAKE_HOLD,
	 * this function may behave differently than calling move_absolute(0)
	 * or move_relative(0).
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 189 2 203 5 18446744073709551615 7 virtual 204 2 204 9 18446744073709551615 3 std 204 10 204 13 2 2 :: 204 13 204 15 31 7 int32_t 204 15 204 22 31 5 brake 204 23 204 28 31 1 ( 204 28 204 29 31 4 void 204 29 204 33 18446744073709551615 1 ) 204 33 204 34 31 5 const 204 35 204 40 18446744073709551615 1 ; 204 40 204 41 18446744073709551615 581 /**
	 * Changes the output velocity for a profiled movement (motor_move_absolute()
	 * or motor_move_relative()). This will have no effect if the motor is not
	 * following a profiled movement.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \param velocity
	 *        The new motor velocity from +-100, +-200, or +-600 depending on the
	 *        motor's gearset
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 206 2 221 5 18446744073709551615 7 virtual 222 2 222 9 18446744073709551615 3 std 222 10 222 13 2 2 :: 222 13 222 15 32 7 int32_t 222 15 222 22 32 24 modify_profiled_velocity 222 23 222 47 32 1 ( 222 47 222 48 32 5 const 222 48 222 53 18446744073709551615 3 std 222 54 222 57 2 2 :: 222 57 222 59 18446744073709551615 7 int32_t 222 59 222 66 33 8 velocity 222 67 222 75 33 1 ) 222 75 222 76 32 5 const 222 77 222 82 18446744073709551615 1 ; 222 82 222 83 18446744073709551615 330 /**
	 * Gets the target position set for the motor by the user.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return The target position in its encoder units or PROS_ERR_F if the
	 * operation failed, setting errno.
	 */ 224 2 233 5 18446744073709551615 7 virtual 234 2 234 9 18446744073709551615 6 double 234 10 234 16 18446744073709551615 19 get_target_position 234 17 234 36 34 1 ( 234 36 234 37 34 4 void 234 37 234 41 18446744073709551615 1 ) 234 41 234 42 34 5 const 234 43 234 48 18446744073709551615 1 ; 234 48 234 49 18446744073709551615 343 /**
	 * Gets the velocity commanded to the motor by the user.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return The commanded motor velocity from +-100, +-200, or +-600, or
	 * PROS_ERR if the operation failed, setting errno.
	 */ 236 2 245 5 18446744073709551615 7 virtual 246 2 246 9 18446744073709551615 3 std 246 10 246 13 2 2 :: 246 13 246 15 35 7 int32_t 246 15 246 22 35 19 get_target_velocity 246 23 246 42 35 1 ( 246 42 246 43 35 4 void 246 43 246 47 18446744073709551615 1 ) 246 47 246 48 35 5 const 246 49 246 54 18446744073709551615 1 ; 246 54 246 55 18446744073709551615 78 /****************************************************************************/ 248 2 248 80 18446744073709551615 78 /**                        Motor telemetry functions                       **/ 249 2 249 80 18446744073709551615 78 /**                                                                        **/ 250 2 250 80 18446744073709551615 78 /**    These functions allow programmers to collect telemetry from motors  **/ 251 2 251 80 18446744073709551615 78 /****************************************************************************/ 252 2 252 80 18446744073709551615 307 /**
	 * Gets the actual velocity of the motor.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return The motor's actual velocity in RPM or PROS_ERR_F if the operation
	 * failed, setting errno.
	 */ 254 2 263 5 18446744073709551615 7 virtual 264 2 264 9 18446744073709551615 6 double 264 10 264 16 18446744073709551615 19 get_actual_velocity 264 17 264 36 36 1 ( 264 36 264 37 36 4 void 264 37 264 41 18446744073709551615 1 ) 264 41 264 42 36 5 const 264 43 264 48 18446744073709551615 1 ; 264 48 264 49 18446744073709551615 300 /**
	 * Gets the current drawn by the motor in mA.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return The motor's current in mA or PROS_ERR if the operation failed,
	 * setting errno.
	 */ 266 2 275 5 18446744073709551615 7 virtual 276 2 276 9 18446744073709551615 3 std 276 10 276 13 2 2 :: 276 13 276 15 37 7 int32_t 276 15 276 22 37 16 get_current_draw 276 23 276 39 37 1 ( 276 39 276 40 37 4 void 276 40 276 44 18446744073709551615 1 ) 276 44 276 45 37 5 const 276 46 276 51 18446744073709551615 1 ; 276 51 276 52 18446744073709551615 359 /**
	 * Gets the direction of movement for the motor.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return 1 for moving in the positive direction, -1 for moving in the
	 * negative direction, and PROS_ERR if the operation failed, setting errno.
	 */ 278 2 287 5 18446744073709551615 7 virtual 288 2 288 9 18446744073709551615 3 std 288 10 288 13 2 2 :: 288 13 288 15 38 7 int32_t 288 15 288 22 38 13 get_direction 288 23 288 36 38 1 ( 288 36 288 37 38 4 void 288 37 288 41 18446744073709551615 1 ) 288 41 288 42 38 5 const 288 43 288 48 18446744073709551615 1 ; 288 48 288 49 18446744073709551615 507 /**
	 * Gets the efficiency of the motor in percent.
	 *
	 * An efficiency of 100% means that the motor is moving electrically while
	 * drawing no electrical power, and an efficiency of 0% means that the motor
	 * is drawing power but not moving.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return The motor's efficiency in percent or PROS_ERR_F if the operation
	 * failed, setting errno.
	 */ 290 2 303 5 18446744073709551615 7 virtual 304 2 304 9 18446744073709551615 6 double 304 10 304 16 18446744073709551615 14 get_efficiency 304 17 304 31 39 1 ( 304 31 304 32 39 4 void 304 32 304 36 18446744073709551615 1 ) 304 36 304 37 39 5 const 304 38 304 43 18446744073709551615 1 ; 304 43 304 44 18446744073709551615 383 /**
	 * Checks if the motor is drawing over its current limit.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return 1 if the motor's current limit is being exceeded and 0 if the
	 * current limit is not exceeded, or PROS_ERR if the operation failed, setting
	 * errno.
	 */ 306 2 316 5 18446744073709551615 7 virtual 317 2 317 9 18446744073709551615 3 std 317 10 317 13 2 2 :: 317 13 317 15 40 7 int32_t 317 15 317 22 40 15 is_over_current 317 23 317 38 40 1 ( 317 38 317 39 40 4 void 317 39 317 43 18446744073709551615 1 ) 317 43 317 44 40 5 const 317 45 317 50 18446744073709551615 1 ; 317 50 317 51 18446744073709551615 498 /**
	 * Checks if the motor is stopped.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \note Although this function forwards data from the motor, the motor
	 * presently does not provide any value. This function returns PROS_ERR with
	 * errno set to ENOSYS.
	 *
	 * \return 1 if the motor is not moving, 0 if the motor is moving, or PROS_ERR
	 * if the operation failed, setting errno
	 */ 319 2 332 5 18446744073709551615 7 virtual 333 2 333 9 18446744073709551615 3 std 333 10 333 13 2 2 :: 333 13 333 15 41 7 int32_t 333 15 333 22 41 10 is_stopped 333 23 333 33 41 1 ( 333 33 333 34 41 4 void 333 34 333 38 18446744073709551615 1 ) 333 38 333 39 41 5 const 333 40 333 45 18446744073709551615 1 ; 333 45 333 46 18446744073709551615 553 /**
	 * Checks if the motor is at its zero position.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \note Although this function forwards data from the motor, the motor
	 * presently does not provide any value. This function returns PROS_ERR with
	 * errno set to ENOSYS.
	 *
	 * \return 1 if the motor is at zero absolute position, 0 if the motor has
	 * moved from its absolute zero, or PROS_ERR if the operation failed, setting
	 * errno
	 */ 335 2 349 5 18446744073709551615 7 virtual 350 2 350 9 18446744073709551615 3 std 350 10 350 13 2 2 :: 350 13 350 15 42 7 int32_t 350 15 350 22 42 22 get_zero_position_flag 350 23 350 45 42 1 ( 350 45 350 46 42 4 void 350 46 350 50 18446744073709551615 1 ) 350 50 350 51 42 5 const 350 52 350 57 18446744073709551615 1 ; 350 57 350 58 18446744073709551615 331 /**
	 * Gets the faults experienced by the motor.
	 *
	 * Compare this bitfield to the bitmasks in pros::motor_fault_e_t.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return A bitfield containing the motor's faults.
	 */ 352 2 362 5 18446744073709551615 7 virtual 363 2 363 9 18446744073709551615 3 std 363 10 363 13 2 2 :: 363 13 363 15 43 8 uint32_t 363 15 363 23 43 10 get_faults 363 24 363 34 43 1 ( 363 34 363 35 43 4 void 363 35 363 39 18446744073709551615 1 ) 363 39 363 40 43 5 const 363 41 363 46 18446744073709551615 1 ; 363 46 363 47 18446744073709551615 332 /**
	 * Gets the flags set by the motor's operation.
	 *
	 * Compare this bitfield to the bitmasks in pros::motor_flag_e_t.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return A bitfield containing the motor's flags.
	 */ 365 2 375 5 18446744073709551615 7 virtual 376 2 376 9 18446744073709551615 3 std 376 10 376 13 2 2 :: 376 13 376 15 44 8 uint32_t 376 15 376 23 44 9 get_flags 376 24 376 33 44 1 ( 376 33 376 34 44 4 void 376 34 376 38 18446744073709551615 1 ) 376 38 376 39 44 5 const 376 40 376 45 18446744073709551615 1 ; 376 45 376 46 18446744073709551615 559 /**
	 * Gets the raw encoder count of the motor at a given timestamp.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \param[in] timestamp
	 *            A pointer to a time in milliseconds for which the encoder count
	 *            will be returned. If NULL, the timestamp at which the encoder
	 *            count was read will not be supplied
	 *
	 * \return The raw encoder count at the given timestamp or PROS_ERR if the
	 * operation failed.
	 */ 378 2 392 5 18446744073709551615 7 virtual 393 2 393 9 18446744073709551615 3 std 393 10 393 13 2 2 :: 393 13 393 15 45 7 int32_t 393 15 393 22 45 16 get_raw_position 393 23 393 39 45 1 ( 393 39 393 40 45 3 std 393 40 393 43 2 2 :: 393 43 393 45 18446744073709551615 8 uint32_t 393 45 393 53 46 1 * 393 53 393 54 18446744073709551615 5 const 393 55 393 60 18446744073709551615 9 timestamp 393 61 393 70 46 1 ) 393 70 393 71 45 5 const 393 72 393 77 18446744073709551615 1 ; 393 77 393 78 18446744073709551615 362 /**
	 * Gets the temperature limit flag for the motor.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return 1 if the temperature limit is exceeded and 0 if the temperature is
	 * below the limit, or PROS_ERR if the operation failed, setting errno.
	 */ 395 2 404 5 18446744073709551615 7 virtual 405 2 405 9 18446744073709551615 3 std 405 10 405 13 2 2 :: 405 13 405 15 47 7 int32_t 405 15 405 22 47 12 is_over_temp 405 23 405 35 47 1 ( 405 35 405 36 47 4 void 405 36 405 40 18446744073709551615 1 ) 405 40 405 41 47 5 const 405 42 405 47 18446744073709551615 1 ; 405 47 405 48 18446744073709551615 346 /**
	 * Gets the absolute position of the motor in its encoder units.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return The motor's absolute position in its encoder units or PROS_ERR_F
	 * if the operation failed, setting errno.
	 */ 407 2 416 5 18446744073709551615 7 virtual 417 2 417 9 18446744073709551615 6 double 417 10 417 16 18446744073709551615 12 get_position 417 17 417 29 48 1 ( 417 29 417 30 48 4 void 417 30 417 34 18446744073709551615 1 ) 417 34 417 35 48 5 const 417 36 417 41 18446744073709551615 1 ; 417 41 417 42 18446744073709551615 309 /**
	 * Gets the power drawn by the motor in Watts.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return The motor's power draw in Watts or PROS_ERR_F if the operation
	 * failed, setting errno.
	 */ 419 2 428 5 18446744073709551615 7 virtual 429 2 429 9 18446744073709551615 6 double 429 10 429 16 18446744073709551615 9 get_power 429 17 429 26 49 1 ( 429 26 429 27 49 4 void 429 27 429 31 18446744073709551615 1 ) 429 31 429 32 49 5 const 429 33 429 38 18446744073709551615 1 ; 429 38 429 39 18446744073709551615 330 /**
	 * Gets the temperature of the motor in degrees Celsius.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return The motor's temperature in degrees Celsius or PROS_ERR_F if the
	 * operation failed, setting errno.
	 */ 431 2 440 5 18446744073709551615 7 virtual 441 2 441 9 18446744073709551615 6 double 441 10 441 16 18446744073709551615 15 get_temperature 441 17 441 32 50 1 ( 441 32 441 33 50 4 void 441 33 441 37 18446744073709551615 1 ) 441 37 441 38 50 5 const 441 39 441 44 18446744073709551615 1 ; 441 44 441 45 18446744073709551615 320 /**
	 * Gets the torque generated by the motor in Newton Meters (Nm).
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return The motor's torque in Nm or PROS_ERR_F if the operation failed,
	 * setting errno.
	 */ 443 2 452 5 18446744073709551615 7 virtual 453 2 453 9 18446744073709551615 6 double 453 10 453 16 18446744073709551615 10 get_torque 453 17 453 27 51 1 ( 453 27 453 28 51 4 void 453 28 453 32 18446744073709551615 1 ) 453 32 453 33 51 5 const 453 34 453 39 18446744073709551615 1 ; 453 39 453 40 18446744073709551615 319 /**
	 * Gets the voltage delivered to the motor in millivolts.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return The motor's voltage in mV or PROS_ERR_F if the operation failed,
	 * setting errno.
	 * 
	 */ 455 2 465 5 18446744073709551615 7 virtual 466 2 466 9 18446744073709551615 3 std 466 10 466 13 2 2 :: 466 13 466 15 52 7 int32_t 466 15 466 22 52 11 get_voltage 466 23 466 34 52 1 ( 466 34 466 35 52 4 void 466 35 466 39 18446744073709551615 1 ) 466 39 466 40 52 5 const 466 41 466 46 18446744073709551615 1 ; 466 46 466 47 18446744073709551615 78 /****************************************************************************/ 468 2 468 80 18446744073709551615 78 /**                      Motor configuration functions                     **/ 469 2 469 80 18446744073709551615 78 /**                                                                        **/ 470 2 470 80 18446744073709551615 78 /**  These functions allow programmers to configure the behavior of motors **/ 471 2 471 80 18446744073709551615 78 /****************************************************************************/ 472 2 472 80 18446744073709551615 491 /**
	 * Sets the position for the motor in its encoder units.
	 *
	 * This will be the future reference point for the motor's "absolute"
	 * position.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \param position
	 *        The new reference position in its encoder units
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 474 2 489 5 18446744073709551615 7 virtual 490 2 490 9 18446744073709551615 3 std 490 10 490 13 2 2 :: 490 13 490 15 53 7 int32_t 490 15 490 22 53 17 set_zero_position 490 23 490 40 53 1 ( 490 40 490 41 53 5 const 490 41 490 46 18446744073709551615 6 double 490 47 490 53 18446744073709551615 8 position 490 54 490 62 54 1 ) 490 62 490 63 53 5 const 490 64 490 69 18446744073709551615 1 ; 490 69 490 70 18446744073709551615 337 /**
	 * Sets the "absolute" zero position of the motor to its current position.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 492 2 501 5 18446744073709551615 7 virtual 502 2 502 9 18446744073709551615 3 std 502 10 502 13 2 2 :: 502 13 502 15 55 7 int32_t 502 15 502 22 55 13 tare_position 502 23 502 36 55 1 ( 502 36 502 37 55 4 void 502 37 502 41 18446744073709551615 1 ) 502 41 502 42 55 5 const 502 43 502 48 18446744073709551615 1 ; 502 48 502 49 18446744073709551615 389 /**
	 * Sets one of motor_brake_mode_e_t to the motor.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \param mode
	 *        The motor_brake_mode_e_t to set for the motor
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 504 2 516 5 18446744073709551615 7 virtual 517 2 517 9 18446744073709551615 3 std 517 10 517 13 2 2 :: 517 13 517 15 56 7 int32_t 517 15 517 22 56 14 set_brake_mode 517 23 517 37 56 1 ( 517 37 517 38 56 5 const 517 38 517 43 18446744073709551615 20 motor_brake_mode_e_t 517 44 517 64 57 4 mode 517 65 517 69 58 1 ) 517 69 517 70 56 5 const 517 71 517 76 18446744073709551615 1 ; 517 76 517 77 18446744073709551615 369 /**
	 * Sets the current limit for the motor in mA.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \param limit
	 *        The new current limit in mA
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 519 2 531 5 18446744073709551615 7 virtual 532 2 532 9 18446744073709551615 3 std 532 10 532 13 2 2 :: 532 13 532 15 59 7 int32_t 532 15 532 22 59 17 set_current_limit 532 23 532 40 59 1 ( 532 40 532 41 59 5 const 532 41 532 46 18446744073709551615 3 std 532 47 532 50 2 2 :: 532 50 532 52 18446744073709551615 7 int32_t 532 52 532 59 60 5 limit 532 60 532 65 60 1 ) 532 65 532 66 59 5 const 532 67 532 72 18446744073709551615 1 ; 532 72 532 73 18446744073709551615 384 /**
	 * Sets one of motor_encoder_units_e_t for the motor encoder.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \param units
	 *        The new motor encoder units
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 534 2 546 5 18446744073709551615 7 virtual 547 2 547 9 18446744073709551615 3 std 547 10 547 13 2 2 :: 547 13 547 15 61 7 int32_t 547 15 547 22 61 17 set_encoder_units 547 23 547 40 61 1 ( 547 40 547 41 61 5 const 547 41 547 46 18446744073709551615 23 motor_encoder_units_e_t 547 47 547 70 7 5 units 547 71 547 76 62 1 ) 547 76 547 77 61 5 const 547 78 547 83 18446744073709551615 1 ; 547 83 547 84 18446744073709551615 366 /**
	 * Sets one of motor_gearset_e_t for the motor.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \param gearset
	 *        The new motor gearset
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 549 2 561 5 18446744073709551615 7 virtual 562 2 562 9 18446744073709551615 3 std 562 10 562 13 2 2 :: 562 13 562 15 63 7 int32_t 562 15 562 22 63 11 set_gearing 562 23 562 34 63 1 ( 562 34 562 35 63 5 const 562 35 562 40 18446744073709551615 17 motor_gearset_e_t 562 41 562 58 4 7 gearset 562 59 562 66 64 1 ) 562 66 562 67 63 5 const 562 68 562 73 18446744073709551615 1 ; 562 73 562 74 18446744073709551615 532 /**
	 * Takes in floating point values and returns a properly formatted pid struct.
	 * The motor_pid_s_t struct is in 4.4 format, i.e. 0x20 is 2.0, 0x21 is
	 * 2.0625, etc.
	 * This function will convert the floating point values to the nearest 4.4
	 * value.
	 *
	 * \param kf
	 *        The feedforward constant
	 * \param kp
	 *        The proportional constant
	 * \param ki
	 *        The integral constant
	 * \param kd
	 *        The derivative constant
	 *
	 * \return A motor_pid_s_t struct formatted properly in 4.4.
	 */ 564 2 581 5 18446744073709551615 1 [ 582 2 582 3 18446744073709551615 1 [ 582 3 582 4 18446744073709551615 10 deprecated 582 4 582 14 1 1 ( 582 14 582 15 18446744073709551615 87 "Changing these values is not supported by VEX and may lead to permanent motor damage." 583 6 583 93 18446744073709551615 1 ) 583 93 583 94 18446744073709551615 1 ] 583 94 583 95 18446744073709551615 1 ] 583 95 583 96 18446744073709551615 6 static 583 97 583 103 18446744073709551615 13 motor_pid_s_t 583 104 583 117 65 11 convert_pid 584 2 584 13 66 1 ( 584 13 584 14 66 6 double 584 14 584 20 18446744073709551615 2 kf 584 21 584 23 67 1 , 584 23 584 24 66 6 double 584 25 584 31 18446744073709551615 2 kp 584 32 584 34 68 1 , 584 34 584 35 66 6 double 584 36 584 42 18446744073709551615 2 ki 584 43 584 45 69 1 , 584 45 584 46 66 6 double 584 47 584 53 18446744073709551615 2 kd 584 54 584 56 70 1 ) 584 56 584 57 66 1 ; 584 57 584 58 18446744073709551615 914 /**
	 * Takes in floating point values and returns a properly formatted pid struct.
	 * The motor_pid_s_t struct is in 4.4 format, i.e. 0x20 is 2.0, 0x21 is
	 * 2.0625, etc.
	 * This function will convert the floating point values to the nearest 4.4
	 * value.
	 *
	 * \param kf
	 *        The feedforward constant
	 * \param kp
	 *        The proportional constant
	 * \param ki
	 *        The integral constant
	 * \param kd
	 *        The derivative constant
	 * \param filter
	 *        A constant used for filtering the profile acceleration
	 * \param limit
	 *        The integral limit
	 * \param threshold
	 *        The threshold for determining if a position movement has reached its
	 *        goal. This has no effect for velocity PID calculations.
	 * \param loopspeed
	 *        The rate at which the PID computation is run in ms
	 *
	 * \return A motor_pid_s_t struct formatted properly in 4.4.
	 */ 586 2 612 5 18446744073709551615 1 [ 613 2 613 3 18446744073709551615 1 [ 613 3 613 4 18446744073709551615 10 deprecated 613 4 613 14 1 1 ( 613 14 613 15 18446744073709551615 80 "Changing these values is not supported by VEX and may lead to permanent motor " 614 6 614 86 18446744073709551615 9 "damage." 615 6 615 15 18446744073709551615 1 ) 615 15 615 16 18446744073709551615 1 ] 615 16 615 17 18446744073709551615 1 ] 615 17 615 18 18446744073709551615 6 static 615 19 615 25 18446744073709551615 18 motor_pid_full_s_t 615 26 615 44 71 16 convert_pid_full 616 2 616 18 72 1 ( 616 18 616 19 72 6 double 616 19 616 25 18446744073709551615 2 kf 616 26 616 28 73 1 , 616 28 616 29 72 6 double 616 30 616 36 18446744073709551615 2 kp 616 37 616 39 74 1 , 616 39 616 40 72 6 double 616 41 616 47 18446744073709551615 2 ki 616 48 616 50 75 1 , 616 50 616 51 72 6 double 616 52 616 58 18446744073709551615 2 kd 616 59 616 61 76 1 , 616 61 616 62 72 6 double 616 63 616 69 18446744073709551615 6 filter 616 70 616 76 77 1 , 616 76 616 77 72 6 double 616 78 616 84 18446744073709551615 5 limit 616 85 616 90 78 1 , 616 90 616 91 72 6 double 616 92 616 98 18446744073709551615 9 threshold 616 99 616 108 79 1 , 616 108 616 109 72 6 double 617 19 617 25 18446744073709551615 9 loopspeed 617 26 617 35 80 1 ) 617 35 617 36 72 1 ; 617 36 617 37 18446744073709551615 510 /**
	 * Sets one of motor_pid_s_t for the motor. This intended to just modify the
	 * main PID constants.
	 *
	 * Only non-zero values of the struct will change the existing motor
	 * constants.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \param pid
	 *        The new motor PID constants
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 619 2 635 5 18446744073709551615 1 [ 636 2 636 3 18446744073709551615 1 [ 636 3 636 4 18446744073709551615 10 deprecated 636 4 636 14 1 1 ( 636 14 636 15 18446744073709551615 87 "Changing these values is not supported by VEX and may lead to permanent motor damage." 637 6 637 93 18446744073709551615 1 ) 637 93 637 94 18446744073709551615 1 ] 637 94 637 95 18446744073709551615 1 ] 637 95 637 96 18446744073709551615 7 virtual 637 97 637 104 18446744073709551615 3 std 637 105 637 108 2 2 :: 637 108 637 110 81 7 int32_t 637 110 637 117 81 11 set_pos_pid 638 2 638 13 81 1 ( 638 13 638 14 81 5 const 638 14 638 19 18446744073709551615 13 motor_pid_s_t 638 20 638 33 65 3 pid 638 34 638 37 82 1 ) 638 37 638 38 81 5 const 638 39 638 44 18446744073709551615 1 ; 638 44 638 45 18446744073709551615 458 /**
	 * Sets one of motor_pid_full_s_t for the motor.
	 *
	 * Only non-zero values of the struct will change the existing motor
	 * constants.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \param pid
	 *        The new motor PID constants
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 640 2 655 5 18446744073709551615 1 [ 656 2 656 3 18446744073709551615 1 [ 656 3 656 4 18446744073709551615 10 deprecated 656 4 656 14 1 1 ( 656 14 656 15 18446744073709551615 87 "Changing these values is not supported by VEX and may lead to permanent motor damage." 657 6 657 93 18446744073709551615 1 ) 657 93 657 94 18446744073709551615 1 ] 657 94 657 95 18446744073709551615 1 ] 657 95 657 96 18446744073709551615 7 virtual 657 97 657 104 18446744073709551615 3 std 657 105 657 108 2 2 :: 657 108 657 110 83 7 int32_t 657 110 657 117 83 16 set_pos_pid_full 658 2 658 18 83 1 ( 658 18 658 19 83 5 const 658 19 658 24 18446744073709551615 18 motor_pid_full_s_t 658 25 658 43 71 3 pid 658 44 658 47 84 1 ) 658 47 658 48 83 5 const 658 49 658 54 18446744073709551615 1 ; 658 54 658 55 18446744073709551615 510 /**
	 * Sets one of motor_pid_s_t for the motor. This intended to just modify the
	 * main PID constants.
	 *
	 * Only non-zero values of the struct will change the existing motor
	 * constants.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \param pid
	 *        The new motor PID constants
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 660 2 676 5 18446744073709551615 1 [ 677 2 677 3 18446744073709551615 1 [ 677 3 677 4 18446744073709551615 10 deprecated 677 4 677 14 1 1 ( 677 14 677 15 18446744073709551615 87 "Changing these values is not supported by VEX and may lead to permanent motor damage." 678 6 678 93 18446744073709551615 1 ) 678 93 678 94 18446744073709551615 1 ] 678 94 678 95 18446744073709551615 1 ] 678 95 678 96 18446744073709551615 7 virtual 678 97 678 104 18446744073709551615 3 std 678 105 678 108 2 2 :: 678 108 678 110 85 7 int32_t 678 110 678 117 85 11 set_vel_pid 679 2 679 13 85 1 ( 679 13 679 14 85 5 const 679 14 679 19 18446744073709551615 13 motor_pid_s_t 679 20 679 33 65 3 pid 679 34 679 37 86 1 ) 679 37 679 38 85 5 const 679 39 679 44 18446744073709551615 1 ; 679 44 679 45 18446744073709551615 458 /**
	 * Sets one of motor_pid_full_s_t for the motor.
	 *
	 * Only non-zero values of the struct will change the existing motor
	 * constants.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \param pid
	 *        The new motor PID constants
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 681 2 696 5 18446744073709551615 1 [ 697 2 697 3 18446744073709551615 1 [ 697 3 697 4 18446744073709551615 10 deprecated 697 4 697 14 1 1 ( 697 14 697 15 18446744073709551615 87 "Changing these values is not supported by VEX and may lead to permanent motor damage." 698 6 698 93 18446744073709551615 1 ) 698 93 698 94 18446744073709551615 1 ] 698 94 698 95 18446744073709551615 1 ] 698 95 698 96 18446744073709551615 7 virtual 698 97 698 104 18446744073709551615 3 std 698 105 698 108 2 2 :: 698 108 698 110 87 7 int32_t 698 110 698 117 87 16 set_vel_pid_full 699 2 699 18 87 1 ( 699 18 699 19 87 5 const 699 19 699 24 18446744073709551615 18 motor_pid_full_s_t 699 25 699 43 71 3 pid 699 44 699 47 88 1 ) 699 47 699 48 87 5 const 699 49 699 54 18446744073709551615 1 ; 699 54 699 55 18446744073709551615 459 /**
	 * Sets the reverse flag for the motor.
	 *
	 * This will invert its movements and the values returned for its position.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \param reverse
	 *        True reverses the motor, false is default
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 701 2 715 5 18446744073709551615 7 virtual 716 2 716 9 18446744073709551615 3 std 716 10 716 13 2 2 :: 716 13 716 15 89 7 int32_t 716 15 716 22 89 12 set_reversed 716 23 716 35 89 1 ( 716 35 716 36 89 5 const 716 36 716 41 18446744073709551615 4 bool 716 42 716 46 18446744073709551615 7 reverse 716 47 716 54 90 1 ) 716 54 716 55 89 5 const 716 56 716 61 18446744073709551615 1 ; 716 61 716 62 18446744073709551615 375 /**
	 * Sets the voltage limit for the motor in Volts.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \param limit
	 *        The new voltage limit in Volts
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 718 2 730 5 18446744073709551615 7 virtual 731 2 731 9 18446744073709551615 3 std 731 10 731 13 2 2 :: 731 13 731 15 91 7 int32_t 731 15 731 22 91 17 set_voltage_limit 731 23 731 40 91 1 ( 731 40 731 41 91 5 const 731 41 731 46 18446744073709551615 3 std 731 47 731 50 2 2 :: 731 50 731 52 18446744073709551615 7 int32_t 731 52 731 59 92 5 limit 731 60 731 65 92 1 ) 731 65 731 66 91 5 const 731 67 731 72 18446744073709551615 1 ; 731 72 731 73 18446744073709551615 362 /**
	 * Gets the brake mode that was set for the motor.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return One of motor_brake_mode_e_t, according to what was set for the
	 * motor, or E_MOTOR_BRAKE_INVALID if the operation failed, setting errno.
	 */ 733 2 742 5 18446744073709551615 7 virtual 743 2 743 9 18446744073709551615 20 motor_brake_mode_e_t 743 10 743 30 57 14 get_brake_mode 743 31 743 45 93 1 ( 743 45 743 46 93 4 void 743 46 743 50 18446744073709551615 1 ) 743 50 743 51 93 5 const 743 52 743 57 18446744073709551615 1 ; 743 57 743 58 18446744073709551615 345 /**
	 * Gets the current limit for the motor in mA.
	 *
	 * The default value is 2500 mA.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return The motor's current limit in mA or PROS_ERR if the operation failed,
	 * setting errno.
	 */ 745 2 756 5 18446744073709551615 7 virtual 757 2 757 9 18446744073709551615 3 std 757 10 757 13 2 2 :: 757 13 757 15 94 7 int32_t 757 15 757 22 94 17 get_current_limit 757 23 757 40 94 1 ( 757 40 757 41 94 4 void 757 41 757 45 18446744073709551615 1 ) 757 45 757 46 94 5 const 757 47 757 52 18446744073709551615 1 ; 757 52 757 53 18446744073709551615 353 /**
	 * Gets the encoder units that were set for the motor.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return One of motor_encoder_units_e_t according to what is set for the
	 * motor or E_MOTOR_ENCODER_INVALID if the operation failed.
	 */ 759 2 768 5 18446744073709551615 7 virtual 769 2 769 9 18446744073709551615 23 motor_encoder_units_e_t 769 10 769 33 7 17 get_encoder_units 769 34 769 51 95 1 ( 769 51 769 52 95 4 void 769 52 769 56 18446744073709551615 1 ) 769 56 769 57 95 5 const 769 58 769 63 18446744073709551615 1 ; 769 63 769 64 18446744073709551615 335 /**
	 * Gets the gearset that was set for the motor.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return One of motor_gearset_e_t according to what is set for the motor,
	 * or E_GEARSET_INVALID if the operation failed.
	 */ 771 2 780 5 18446744073709551615 7 virtual 781 2 781 9 18446744073709551615 17 motor_gearset_e_t 781 10 781 27 4 11 get_gearing 781 28 781 39 96 1 ( 781 39 781 40 96 4 void 781 40 781 44 18446744073709551615 1 ) 781 44 781 45 96 5 const 781 46 781 51 18446744073709551615 1 ; 781 51 781 52 18446744073709551615 586 /**
	 * Gets the position PID that was set for the motor. This function will return
	 * zero for all of the parameters if the motor_set_pos_pid() or
	 * motor_set_pos_pid_full() functions have not been used.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * Additionally, in an error state all values of the returned struct are set
	 * to their negative maximum values.
	 *
	 * \return A motor_pid_full_s_t containing the position PID constants last set
	 * to the given motor
	 */ 783 2 797 5 18446744073709551615 1 [ 798 2 798 3 18446744073709551615 1 [ 798 3 798 4 18446744073709551615 10 deprecated 798 4 798 14 1 1 ( 798 14 798 15 18446744073709551615 80 "Changing these values is not supported by VEX and may lead to permanent motor " 799 6 799 86 18446744073709551615 9 "damage." 800 6 800 15 18446744073709551615 1 ) 800 15 800 16 18446744073709551615 1 ] 800 16 800 17 18446744073709551615 1 ] 800 17 800 18 18446744073709551615 7 virtual 800 19 800 26 18446744073709551615 18 motor_pid_full_s_t 800 27 800 45 71 11 get_pos_pid 801 2 801 13 97 1 ( 801 13 801 14 97 4 void 801 14 801 18 18446744073709551615 1 ) 801 18 801 19 97 5 const 801 20 801 25 18446744073709551615 1 ; 801 25 801 26 18446744073709551615 586 /**
	 * Gets the velocity PID that was set for the motor. This function will return
	 * zero for all of the parameters if the motor_set_vel_pid() or
	 * motor_set_vel_pid_full() functions have not been used.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * Additionally, in an error state all values of the returned struct are set
	 * to their negative maximum values.
	 *
	 * \return A motor_pid_full_s_t containing the velocity PID constants last set
	 * to the given motor
	 */ 803 2 817 5 18446744073709551615 1 [ 818 2 818 3 18446744073709551615 1 [ 818 3 818 4 18446744073709551615 10 deprecated 818 4 818 14 1 1 ( 818 14 818 15 18446744073709551615 80 "Changing these values is not supported by VEX and may lead to permanent motor " 819 6 819 86 18446744073709551615 9 "damage." 820 6 820 15 18446744073709551615 1 ) 820 15 820 16 18446744073709551615 1 ] 820 16 820 17 18446744073709551615 1 ] 820 17 820 18 18446744073709551615 7 virtual 820 19 820 26 18446744073709551615 18 motor_pid_full_s_t 820 27 820 45 71 11 get_vel_pid 821 2 821 13 98 1 ( 821 13 821 14 98 4 void 821 14 821 18 18446744073709551615 1 ) 821 18 821 19 98 5 const 821 20 821 25 18446744073709551615 1 ; 821 25 821 26 18446744073709551615 363 /**
	 * Gets the operation direction of the motor as set by the user.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return 1 if the motor has been reversed and 0 if the motor was not
	 * reversed, or PROS_ERR if the operation failed, setting errno.
	 */ 823 2 832 5 18446744073709551615 7 virtual 833 2 833 9 18446744073709551615 3 std 833 10 833 13 2 2 :: 833 13 833 15 99 7 int32_t 833 15 833 22 99 11 is_reversed 833 23 833 34 99 1 ( 833 34 833 35 99 4 void 833 35 833 39 18446744073709551615 1 ) 833 39 833 40 99 5 const 833 41 833 46 18446744073709551615 1 ; 833 46 833 47 18446744073709551615 408 /**
	 * Gets the voltage limit set by the user.
	 *
	 * Default value is 0V, which means that there is no software limitation
	 * imposed on the voltage.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return The motor's voltage limit in V or PROS_ERR if the operation failed,
	 * setting errno.
	 */ 835 2 847 5 18446744073709551615 7 virtual 848 2 848 9 18446744073709551615 3 std 848 10 848 13 2 2 :: 848 13 848 15 100 7 int32_t 848 15 848 22 100 17 get_voltage_limit 848 23 848 40 100 1 ( 848 40 848 41 100 4 void 848 41 848 45 18446744073709551615 1 ) 848 45 848 46 100 5 const 848 47 848 52 18446744073709551615 1 ; 848 52 848 53 18446744073709551615 88 /**
	 * Gets the port number of the motor.
	 *
	 * \return The motor's port number.
	 */ 850 2 854 5 18446744073709551615 7 virtual 855 2 855 9 18446744073709551615 3 std 855 10 855 13 2 2 :: 855 13 855 15 101 7 uint8_t 855 15 855 22 101 8 get_port 855 23 855 31 101 1 ( 855 31 855 32 101 4 void 855 32 855 36 18446744073709551615 1 ) 855 36 855 37 101 5 const 855 38 855 43 18446744073709551615 1 ; 855 43 855 44 18446744073709551615 7 private 857 2 857 9 18446744073709551615 1 : 857 9 857 10 18446744073709551615 5 const 858 2 858 7 18446744073709551615 3 std 858 8 858 11 2 2 :: 858 11 858 13 18446744073709551615 7 uint8_t 858 13 858 20 102 5 _port 858 21 858 26 102 1 ; 858 26 858 27 18446744073709551615 1 } 859 1 859 2 18446744073709551615 1 ; 859 2 859 3 18446744073709551615 5 class 861 1 861 6 18446744073709551615 11 Motor_Group 861 7 861 18 103 1 { 861 19 861 20 18446744073709551615 6 public 862 2 862 8 18446744073709551615 1 : 862 8 862 9 18446744073709551615 11 Motor_Group 863 2 863 13 103 1 ( 863 13 863 14 103 5 const 863 14 863 19 18446744073709551615 3 std 863 20 863 23 2 2 :: 863 23 863 25 18446744073709551615 16 initializer_list 863 25 863 41 104 1 < 863 41 863 42 18446744073709551615 5 Motor 863 42 863 47 1 1 > 863 47 863 48 18446744073709551615 6 motors 863 49 863 55 105 1 ) 863 55 863 56 103 1 ; 863 56 863 57 18446744073709551615 8 explicit 864 2 864 10 18446744073709551615 11 Motor_Group 864 11 864 22 103 1 ( 864 22 864 23 103 5 const 864 23 864 28 18446744073709551615 3 std 864 29 864 32 2 2 :: 864 32 864 34 18446744073709551615 6 vector 864 34 864 40 106 1 < 864 40 864 41 18446744073709551615 4 pros 864 41 864 45 0 2 :: 864 45 864 47 18446744073709551615 5 Motor 864 47 864 52 1 1 > 864 52 864 53 18446744073709551615 1 & 864 53 864 54 18446744073709551615 6 motors 864 55 864 61 107 1 ) 864 61 864 62 103 1 ; 864 62 864 63 18446744073709551615 8 explicit 865 2 865 10 18446744073709551615 11 Motor_Group 865 11 865 22 103 1 ( 865 22 865 23 103 5 const 865 23 865 28 18446744073709551615 3 std 865 29 865 32 2 2 :: 865 32 865 34 18446744073709551615 16 initializer_list 865 34 865 50 104 1 < 865 50 865 51 18446744073709551615 3 std 865 51 865 54 2 2 :: 865 54 865 56 18446744073709551615 6 int8_t 865 56 865 62 108 1 > 865 62 865 63 18446744073709551615 11 motor_ports 865 64 865 75 108 1 ) 865 75 865 76 103 1 ; 865 76 865 77 18446744073709551615 8 explicit 866 2 866 10 18446744073709551615 11 Motor_Group 866 11 866 22 103 1 ( 866 22 866 23 103 5 const 866 23 866 28 18446744073709551615 3 std 866 29 866 32 2 2 :: 866 32 866 34 18446744073709551615 6 vector 866 34 866 40 106 1 < 866 40 866 41 18446744073709551615 3 std 866 41 866 44 2 2 :: 866 44 866 46 18446744073709551615 6 int8_t 866 46 866 52 109 1 > 866 52 866 53 18446744073709551615 11 motor_ports 866 54 866 65 109 1 ) 866 65 866 66 103 1 ; 866 66 866 67 18446744073709551615 32 // Pass by value to preserve ABI 866 68 866 100 18446744073709551615 78 /****************************************************************************/ 868 2 868 80 18446744073709551615 78 /**                      Motor Group movement functions                    **/ 869 2 869 80 18446744073709551615 78 /**                                                                        **/ 870 2 870 80 18446744073709551615 78 /**       These functions allow programmers to make motor groups move      **/ 871 2 871 80 18446744073709551615 78 /****************************************************************************/ 872 2 872 80 18446744073709551615 703 /**
	 * Sets the voltage for all the motors in the motor group from -128 to 127.
	 *
	 * This is designed to map easily to the input from the controller's analog
	 * stick for simple opcontrol use. The actual behavior of the motor is
	 * analogous to use of pros::Motor::move() on each motor individually
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - One of the ports cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \param voltage
	 *        The new motor voltage from -127 to 127
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 873 2 890 5 18446744073709551615 3 std 891 2 891 5 2 2 :: 891 5 891 7 110 7 int32_t 891 7 891 14 110 8 operator 891 15 891 23 110 1 = 891 23 891 24 110 1 ( 891 24 891 25 110 3 std 891 25 891 28 2 2 :: 891 28 891 30 18446744073709551615 7 int32_t 891 30 891 37 111 1 ) 891 37 891 38 110 1 ; 891 38 891 39 18446744073709551615 711 /**
	 * Sets the voltage for the motors in the motor group from -127 to 127.
	 *
	 * This is designed to map easily to the input from the controller's analog
	 * stick for simple opcontrol use. The actual behavior of the motor is
	 * analogous to use of motor_move(), or motorSet() from the
	 * PROS 2 API on each motor.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \param voltage
	 *        The new motor voltage from -127 to 127
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 893 2 911 5 18446744073709551615 3 std 912 2 912 5 2 2 :: 912 5 912 7 112 7 int32_t 912 7 912 14 112 4 move 912 15 912 19 112 1 ( 912 19 912 20 112 3 std 912 20 912 23 2 2 :: 912 23 912 25 18446744073709551615 7 int32_t 912 25 912 32 113 7 voltage 912 33 912 40 113 1 ) 912 40 912 41 112 1 ; 912 41 912 42 18446744073709551615 881 /**
	 * Sets the target absolute position for the motors to move to.
	 *
	 * This movement is relative to the position of the motors when initialized or
	 * the position when it was most recently reset with
	 * pros::Motor::set_zero_position().
	 *
	 * \note This function simply sets the target for the motors, it does not block
	 * program execution until the movement finishes.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \param position
	 *        The absolute position to move to in the motors' encoder units
	 * \param velocity
	 *        The maximum allowable velocity for the movement in RPM
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 914 2 936 5 18446744073709551615 3 std 937 2 937 5 2 2 :: 937 5 937 7 114 7 int32_t 937 7 937 14 114 13 move_absolute 937 15 937 28 114 1 ( 937 28 937 29 114 5 const 937 29 937 34 18446744073709551615 6 double 937 35 937 41 18446744073709551615 8 position 937 42 937 50 115 1 , 937 50 937 51 114 5 const 937 52 937 57 18446744073709551615 3 std 937 58 937 61 2 2 :: 937 61 937 63 18446744073709551615 7 int32_t 937 63 937 70 116 8 velocity 937 71 937 79 116 1 ) 937 79 937 80 114 1 ; 937 80 937 81 18446744073709551615 967 /**
	 * Sets the relative target position for the motor to move to.
	 *
	 * This movement is relative to the current position of the motor as given in
	 * pros::Motor::motor_get_position(). Providing 10.0 as the position parameter
	 * would result in the motor moving clockwise 10 units, no matter what the
	 * current position is.
	 *
	 * \note This function simply sets the target for the motor, it does not block
	 * program execution until the movement finishes.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \param position
	 *        The relative position to move to in the motor's encoder units
	 * \param velocity
	 *        The maximum allowable velocity for the movement in RPM
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 939 2 962 5 18446744073709551615 3 std 963 2 963 5 2 2 :: 963 5 963 7 117 7 int32_t 963 7 963 14 117 13 move_relative 963 15 963 28 117 1 ( 963 28 963 29 117 5 const 963 29 963 34 18446744073709551615 6 double 963 35 963 41 18446744073709551615 8 position 963 42 963 50 118 1 , 963 50 963 51 117 5 const 963 52 963 57 18446744073709551615 3 std 963 58 963 61 2 2 :: 963 61 963 63 18446744073709551615 7 int32_t 963 63 963 70 119 8 velocity 963 71 963 79 119 1 ) 963 79 963 80 117 1 ; 963 80 963 81 18446744073709551615 833 /**
	 * Sets the velocity for the motors.
	 *
	 * This velocity corresponds to different actual speeds depending on the
	 * gearset used for the motor. This results in a range of +-100 for
	 * E_MOTOR_GEARSET_36, +-200 for E_MOTOR_GEARSET_18, and +-600 for
	 * E_MOTOR_GEARSET_6. The velocity is held with PID to ensure consistent
	 * speed, as opposed to setting the motor's voltage.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \param velocity
	 *        The new motor velocity from -+-100, +-200, or +-600 depending on the
	 *        motor's gearset
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 965 2 985 5 18446744073709551615 3 std 986 2 986 5 2 2 :: 986 5 986 7 120 7 int32_t 986 7 986 14 120 13 move_velocity 986 15 986 28 120 1 ( 986 28 986 29 120 5 const 986 29 986 34 18446744073709551615 3 std 986 35 986 38 2 2 :: 986 38 986 40 18446744073709551615 7 int32_t 986 40 986 47 121 8 velocity 986 48 986 56 121 1 ) 986 56 986 57 120 1 ; 986 57 986 58 18446744073709551615 477 /**
	 * Sets the output voltage for the motors from -12000 to 12000 in millivolts.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \param voltage
	 *        The new voltage value from -12000 to 12000
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 988 2 1001 5 18446744073709551615 3 std 1002 2 1002 5 2 2 :: 1002 5 1002 7 122 7 int32_t 1002 7 1002 14 122 12 move_voltage 1002 15 1002 27 122 1 ( 1002 27 1002 28 122 5 const 1002 28 1002 33 18446744073709551615 3 std 1002 34 1002 37 2 2 :: 1002 37 1002 39 18446744073709551615 7 int32_t 1002 39 1002 46 123 7 voltage 1002 47 1002 54 123 1 ) 1002 54 1002 55 122 1 ; 1002 55 1002 56 18446744073709551615 637 /**
	 * Stops the motor using the currently configured brake mode.
	 *
	 * This function sets motor velocity to zero, which will cause it to act
	 * according to the set brake mode. If brake mode is set to MOTOR_BRAKE_HOLD,
	 * this function may behave differently than calling move_absolute(0)
	 * or move_relative(0).
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 1004 2 1019 5 18446744073709551615 3 std 1020 2 1020 5 2 2 :: 1020 5 1020 7 124 7 int32_t 1020 7 1020 14 124 5 brake 1020 15 1020 20 124 1 ( 1020 20 1020 21 124 4 void 1020 21 1020 25 18446744073709551615 1 ) 1020 25 1020 26 124 1 ; 1020 26 1020 27 18446744073709551615 768 /* 
	 * Gets the voltages delivered to the motors in millivolts.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 * 
	 * \return The voltage of the motor in millivolts or PROS_ERR_F if the operation
	 * failed, setting errno.
	 * 
	 * \b Example
	 * \code
	 * void opcontrol() {
	 *   pros::Motor_Group motors({1, 2});
	 *   std::vector<std::uint32_t> voltages;
	 *   while (true) {
	 * 	   voltages = motors.get_voltages();
	 * 
	 *     for (uint32_t i = 0; i < voltages.size(); i++) {
	 * 	     printf("Voltages: %ld\n", voltages[i]);
	 *     }
	 *     pros::delay(20);
	 *   }
	 * }
	 * \endcode
	 * 
	 */ 1022 2 1049 5 18446744073709551615 3 std 1050 2 1050 5 2 2 :: 1050 5 1050 7 125 6 vector 1050 7 1050 13 106 1 < 1050 13 1050 14 125 3 std 1050 14 1050 17 2 2 :: 1050 17 1050 19 125 8 uint32_t 1050 19 1050 27 125 1 > 1050 27 1050 28 125 12 get_voltages 1050 29 1050 41 125 1 ( 1050 41 1050 42 125 4 void 1050 42 1050 46 18446744073709551615 1 ) 1050 46 1050 47 125 1 ; 1050 47 1050 48 18446744073709551615 802 /* 
	 * Get the voltage limits of the motors set by the user.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 * 
	 * \return The voltage limit of the motor in millivolts or PROS_ERR_F if the operation
	 * failed, setting errno.
	 * 
	 * \b Example
	 * \code
	 * void opcontrol() {
	 *   pros::Motor_Group motors({1, 2});
	 *   std::vector<std::uint32_t> voltage_limits;
	 *   while (true) {
	 * 	   voltage_limits = motors.get_voltage_limits();
	 * 
	 *     for (uint32_t i = 0; i < voltage_limits.size(); i++) {
	 * 	     printf("Voltage Limits: %ld\n", voltage_limits[i]);
	 *     }
	 *     pros::delay(20);
	 *   }
	 * }
	 * \endcode
	 */ 1052 2 1078 5 18446744073709551615 3 std 1079 2 1079 5 2 2 :: 1079 5 1079 7 126 6 vector 1079 7 1079 13 106 1 < 1079 13 1079 14 126 3 std 1079 14 1079 17 2 2 :: 1079 17 1079 19 126 8 uint32_t 1079 19 1079 27 126 1 > 1079 27 1079 28 126 18 get_voltage_limits 1079 29 1079 47 126 1 ( 1079 47 1079 48 126 4 void 1079 48 1079 52 18446744073709551615 1 ) 1079 52 1079 53 126 1 ; 1079 53 1079 54 18446744073709551615 1115 /* 
	 * Gets the raw encoder positions of a motor group at a given timestamp.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 * 	
	 * \return A vector of the raw encoder positions of the motors in the motor group
	 * based on the timestamps passed in. If a timestamp is not found for a motor, the
	 * value at that index will be PROS_ERR.
	 * 
	 * \b Example
	 * \code
	 * void opcontrol() {
	 *   pros::Motor_Group motors({1, 2});
	 *   std::vector<std::uint32_t*> timestamps;
	 *   std::vector<std::int32_t> positions;
	 * 	 std::uint32_t temp = 0;
	 *   std::uint32_t temp2 = 0;
	 *   timestamps.push_back(&temp);
	 *   timestamps.push_back(&temp2);
	 * 
	 *   while (true) {
	 *     positions = motors.get_raw_positions(timestamps);
	 * 
	 *     printf("Position: %ld, Time: %ln\n", positions[0], timestamps[0]);
     *	   printf("Position: %ld, Time: %ln\n", positions[1], timestamps[1]);
	 *
	 *     pros::delay(20);
	 *   }
	 * }
	 * \endcode
	 */ 1081 2 1114 5 18446744073709551615 3 std 1115 2 1115 5 2 2 :: 1115 5 1115 7 127 6 vector 1115 7 1115 13 106 1 < 1115 13 1115 14 127 3 std 1115 14 1115 17 2 2 :: 1115 17 1115 19 127 7 int32_t 1115 19 1115 26 127 1 > 1115 26 1115 27 127 17 get_raw_positions 1115 28 1115 45 127 1 ( 1115 45 1115 46 127 3 std 1115 46 1115 49 2 2 :: 1115 49 1115 51 18446744073709551615 6 vector 1115 51 1115 57 106 1 < 1115 57 1115 58 18446744073709551615 3 std 1115 58 1115 61 2 2 :: 1115 61 1115 63 18446744073709551615 8 uint32_t 1115 63 1115 71 128 1 * 1115 71 1115 72 18446744073709551615 1 > 1115 72 1115 73 18446744073709551615 1 & 1115 74 1115 75 18446744073709551615 10 timestamps 1115 75 1115 85 128 1 ) 1115 85 1115 86 127 1 ; 1115 86 1115 87 18446744073709551615 78 /****************************************************************************/ 1116 2 1116 80 18446744073709551615 78 /**                      Motor configuration functions                     **/ 1117 2 1117 80 18446744073709551615 78 /**                                                                        **/ 1118 2 1118 80 18446744073709551615 78 /** These functions let programmers configure the behavior of motor groups **/ 1119 2 1119 80 18446744073709551615 78 /****************************************************************************/ 1120 2 1120 80 18446744073709551615 378 /**
	 * Indexes Motor in the Motor_Group in the same way as an array.
	 * 
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENXIO - Out of bounds on indexing the motor groups.
	 * 
	 * \param i
	 *        The index value in the motor group.
	 *
	 * \return the appropriate Motor reference or the erno if the operation
	 *  failed
	 */ 1122 2 1134 5 18446744073709551615 4 pros 1135 2 1135 6 0 2 :: 1135 6 1135 8 129 5 Motor 1135 8 1135 13 1 1 & 1135 13 1135 14 129 8 operator 1135 15 1135 23 129 1 [ 1135 23 1135 24 129 1 ] 1135 24 1135 25 129 1 ( 1135 25 1135 26 129 3 int 1135 26 1135 29 18446744073709551615 1 i 1135 30 1135 31 130 1 ) 1135 31 1135 32 129 1 ; 1135 32 1135 33 18446744073709551615 319 /**
	 * Indexes Motor in the Motor_Group.
	 * 
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * Throws an std::out_of_range error when indexing out of range
	 * 
	 * \param i
	 *        The index value in the motor group.
	 *
	 * \return the appropriate Motor reference.
	 */ 1138 2 1149 5 18446744073709551615 4 pros 1150 2 1150 6 0 2 :: 1150 6 1150 8 131 5 Motor 1150 8 1150 13 1 1 & 1150 13 1150 14 131 2 at 1150 15 1150 17 131 1 ( 1150 17 1150 18 131 3 int 1150 18 1150 21 18446744073709551615 1 i 1150 22 1150 23 132 1 ) 1150 23 1150 24 131 1 ; 1150 24 1150 25 18446744073709551615 132 /**
	 * Indexes Motor in the Motor_Group in the same way as an array.
	 * 
	 * \return the size of the vector containing motors
	 */ 1152 2 1156 5 18446744073709551615 3 std 1157 2 1157 5 2 2 :: 1157 5 1157 7 133 7 int32_t 1157 7 1157 14 133 4 size 1157 15 1157 19 133 1 ( 1157 19 1157 20 133 1 ) 1157 20 1157 21 133 1 ; 1157 21 1157 22 18446744073709551615 551 /**
	 * Sets the position for the motor in its encoder units.
	 *
	 * This will be the future reference point for the motors' "absolute"
	 * position.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \param position
	 *        The new reference position in its encoder units
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 1159 2 1175 5 18446744073709551615 3 std 1176 2 1176 5 2 2 :: 1176 5 1176 7 134 7 int32_t 1176 7 1176 14 134 17 set_zero_position 1176 15 1176 32 134 1 ( 1176 32 1176 33 134 5 const 1176 33 1176 38 18446744073709551615 6 double 1176 39 1176 45 18446744073709551615 8 position 1176 46 1176 54 135 1 ) 1176 54 1176 55 134 1 ; 1176 55 1176 56 18446744073709551615 455 /**
	 * Sets one of motor_brake_mode_e_t to the motor group.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \param mode
	 *        The motor_brake_mode_e_t to set for the motor
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 1177 2 1190 5 18446744073709551615 3 std 1191 2 1191 5 2 2 :: 1191 5 1191 7 136 7 int32_t 1191 7 1191 14 136 15 set_brake_modes 1191 15 1191 30 136 1 ( 1191 30 1191 31 136 20 motor_brake_mode_e_t 1191 31 1191 51 57 4 mode 1191 52 1191 56 137 1 ) 1191 56 1191 57 136 1 ; 1191 57 1191 58 18446744073709551615 543 /**
	 * Sets the reverse flag for all the motors in the motor group.
	 *
	 * This will invert its movements and the values returned for its position.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \param reverse
	 *        True reverses the motor, false is default
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 1193 2 1208 5 18446744073709551615 3 std 1209 2 1209 5 2 2 :: 1209 5 1209 7 138 7 int32_t 1209 7 1209 14 138 12 set_reversed 1209 15 1209 27 138 1 ( 1209 27 1209 28 138 5 const 1209 28 1209 33 18446744073709551615 4 bool 1209 34 1209 38 18446744073709551615 8 reversed 1209 39 1209 47 139 1 ) 1209 47 1209 48 138 1 ; 1209 48 1209 49 18446744073709551615 440 /**
	 * Sets the voltage limit for all the motors in Volts.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \param limit
	 *        The new voltage limit in Volts
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 1211 2 1224 5 18446744073709551615 3 std 1225 2 1225 5 2 2 :: 1225 5 1225 7 140 7 int32_t 1225 7 1225 14 140 17 set_voltage_limit 1225 15 1225 32 140 1 ( 1225 32 1225 33 140 5 const 1225 33 1225 38 18446744073709551615 3 std 1225 39 1225 42 2 2 :: 1225 42 1225 44 18446744073709551615 7 int32_t 1225 44 1225 51 141 5 limit 1225 52 1225 57 141 1 ) 1225 57 1225 58 140 1 ; 1225 58 1225 59 18446744073709551615 450 /**
	 * Sets one of motor_gearset_e_t for all the motors in the motor group.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \param gearset
	 *        The new motor gearset
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 1226 2 1239 5 18446744073709551615 3 std 1240 2 1240 5 2 2 :: 1240 5 1240 7 142 7 int32_t 1240 7 1240 14 142 11 set_gearing 1240 15 1240 26 142 1 ( 1240 26 1240 27 142 5 const 1240 27 1240 32 18446744073709551615 17 motor_gearset_e_t 1240 33 1240 50 4 7 gearset 1240 51 1240 58 143 1 ) 1240 58 1240 59 142 1 ; 1240 59 1240 60 18446744073709551615 476 /**
	 * Sets one of motor_encoder_units_e_t for the all the motor encoders
	 * in the motor group.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \param units
	 *        The new motor encoder units
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 1242 2 1256 5 18446744073709551615 3 std 1257 2 1257 5 2 2 :: 1257 5 1257 7 144 7 int32_t 1257 7 1257 14 144 17 set_encoder_units 1257 15 1257 32 144 1 ( 1257 32 1257 33 144 5 const 1257 33 1257 38 18446744073709551615 23 motor_encoder_units_e_t 1257 39 1257 62 7 5 units 1257 63 1257 68 145 1 ) 1257 68 1257 69 144 1 ; 1257 69 1257 70 18446744073709551615 403 /**
	 * Sets the "absolute" zero position of the motor group to its current position.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \return 1 if the operation was successful or PROS_ERR if the operation
	 * failed, setting errno.
	 */ 1259 2 1269 5 18446744073709551615 3 std 1270 2 1270 5 2 2 :: 1270 5 1270 7 146 7 int32_t 1270 7 1270 14 146 13 tare_position 1270 15 1270 28 146 1 ( 1270 28 1270 29 146 4 void 1270 29 1270 33 18446744073709551615 1 ) 1270 33 1270 34 146 1 ; 1270 34 1270 35 18446744073709551615 78 /****************************************************************************/ 1272 2 1272 80 18446744073709551615 78 /**                        Motor telemetry functions                       **/ 1273 2 1273 80 18446744073709551615 78 /**                                                                        **/ 1274 2 1274 80 18446744073709551615 78 /** These functions let programmers to collect telemetry from motor groups **/ 1275 2 1275 80 18446744073709551615 78 /****************************************************************************/ 1276 2 1276 80 18446744073709551615 421 /**
	 * Gets the actual velocity of each motor.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \return A vector with the each motor's actual velocity in RPM in the order
	 * or a vector filled with PROS_ERR_F if the operation failed, setting errno.
	 */ 1277 2 1287 5 18446744073709551615 3 std 1288 2 1288 5 2 2 :: 1288 5 1288 7 147 6 vector 1288 7 1288 13 106 1 < 1288 13 1288 14 147 6 double 1288 14 1288 20 18446744073709551615 1 > 1288 20 1288 21 147 21 get_actual_velocities 1288 22 1288 43 147 1 ( 1288 43 1288 44 147 4 void 1288 44 1288 48 18446744073709551615 1 ) 1288 48 1288 49 147 1 ; 1288 49 1288 50 18446744073709551615 393 /**
	 * Gets the velocity commanded to the motor by the user.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return A vector filled with The commanded motor velocities from
	 *  +-100, +-200, or +-600, or a vector filled with PROS_ERR if the operation
	 *  failed, setting errno.
	 */ 1290 2 1300 5 18446744073709551615 3 std 1301 2 1301 5 2 2 :: 1301 5 1301 7 148 6 vector 1301 7 1301 13 106 1 < 1301 13 1301 14 148 3 std 1301 14 1301 17 2 2 :: 1301 17 1301 19 148 7 int32_t 1301 19 1301 26 148 1 > 1301 26 1301 27 148 21 get_target_velocities 1301 28 1301 49 148 1 ( 1301 49 1301 50 148 4 void 1301 50 1301 54 18446744073709551615 1 ) 1301 54 1301 55 148 1 ; 1301 55 1301 56 18446744073709551615 432 /**
	 * Gets the target position set for the motor by the user.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \return A vector filled with the target position in its encoder units
	 * or a vector filled with PROS_ERR_F if the operation failed, setting errno.
	 */ 1303 2 1313 5 18446744073709551615 3 std 1314 2 1314 5 2 2 :: 1314 5 1314 7 149 6 vector 1314 7 1314 13 106 1 < 1314 13 1314 14 149 6 double 1314 14 1314 20 18446744073709551615 1 > 1314 20 1314 21 149 20 get_target_positions 1314 22 1314 42 149 1 ( 1314 42 1314 43 149 4 void 1314 43 1314 47 18446744073709551615 1 ) 1314 47 1314 48 149 1 ; 1314 48 1314 49 18446744073709551615 346 /**
	 * Gets the absolute position of the motor in its encoder units.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return The motor's absolute position in its encoder units or PROS_ERR_F
	 * if the operation failed, setting errno.
	 */ 1316 2 1325 5 18446744073709551615 3 std 1326 2 1326 5 2 2 :: 1326 5 1326 7 150 6 vector 1326 7 1326 13 106 1 < 1326 13 1326 14 150 6 double 1326 14 1326 20 18446744073709551615 1 > 1326 20 1326 21 150 13 get_positions 1326 22 1326 35 150 1 ( 1326 35 1326 36 150 4 void 1326 36 1326 40 18446744073709551615 1 ) 1326 40 1326 41 150 1 ; 1326 41 1326 42 18446744073709551615 610 /**
	 * Gets the efficiency of the motors in percent.
	 *
	 * An efficiency of 100% means that the motor is moving electrically while
	 * drawing no electrical power, and an efficiency of 0% means that the motor
	 * is drawing power but not moving.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \return A vector filled with the motor's efficiency in percent
	 * or a vector filled with PROS_ERR_F if the operation failed, setting errno.
	 */ 1327 2 1341 5 18446744073709551615 3 std 1342 2 1342 5 2 2 :: 1342 5 1342 7 151 6 vector 1342 7 1342 13 106 1 < 1342 13 1342 14 151 6 double 1342 14 1342 20 18446744073709551615 1 > 1342 20 1342 21 151 16 get_efficiencies 1342 22 1342 38 151 1 ( 1342 38 1342 39 151 4 void 1342 39 1342 43 18446744073709551615 1 ) 1342 43 1342 44 151 1 ; 1342 44 1342 45 18446744073709551615 445 /**
	 * Checks if the motors are drawing over its current limit.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \return 1 if the motor's current limit is being exceeded and 0 if the
	 * current limit is not exceeded, or PROS_ERR if the operation failed, setting
	 * errno.
	 */ 1344 2 1355 5 18446744073709551615 3 std 1356 2 1356 5 2 2 :: 1356 5 1356 7 152 6 vector 1356 7 1356 13 106 1 < 1356 13 1356 14 152 3 std 1356 14 1356 17 2 2 :: 1356 17 1356 19 152 7 int32_t 1356 19 1356 26 152 1 > 1356 26 1356 27 152 16 are_over_current 1356 28 1356 44 152 1 ( 1356 44 1356 45 152 4 void 1356 45 1356 49 18446744073709551615 1 ) 1356 49 1356 50 152 1 ; 1356 50 1356 51 18446744073709551615 419 /**
	 * Gets the temperature limit flag for the motors.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return A vector with for each motor a 1 if the temperature limit is
	 * exceeded and 0 if the temperature is below the limit,
	 * or a vector filled with PROS_ERR if the operation failed, setting errno.
	 */ 1358 2 1368 5 18446744073709551615 3 std 1369 2 1369 5 2 2 :: 1369 5 1369 7 153 6 vector 1369 7 1369 13 106 1 < 1369 13 1369 14 153 3 std 1369 14 1369 17 2 2 :: 1369 17 1369 19 153 7 int32_t 1369 19 1369 26 153 1 > 1369 26 1369 27 153 13 are_over_temp 1369 28 1369 41 153 1 ( 1369 41 1369 42 153 4 void 1369 42 1369 46 18446744073709551615 1 ) 1369 46 1369 47 153 1 ; 1369 47 1369 48 18446744073709551615 477 /**
	 * Gets the brake mode that was set for the motors.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \return A Vector with for each motor one of motor_brake_mode_e_t,
	 * according to what was set for the motor, or a vector filled with
	 * E_MOTOR_BRAKE_INVALID if the operation failed, setting errno.
	 */ 1371 2 1382 5 18446744073709551615 3 std 1383 2 1383 5 2 2 :: 1383 5 1383 7 154 6 vector 1383 7 1383 13 106 1 < 1383 13 1383 14 154 4 pros 1383 14 1383 18 0 2 :: 1383 18 1383 20 154 20 motor_brake_mode_e_t 1383 20 1383 40 57 1 > 1383 40 1383 41 154 15 get_brake_modes 1383 42 1383 57 154 1 ( 1383 57 1383 58 154 4 void 1383 58 1383 62 18446744073709551615 1 ) 1383 62 1383 63 154 1 ; 1383 63 1383 64 18446744073709551615 395 /**
	 * Gets the gearset that was set for the motor.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \return One of motor_gearset_e_t according to what is set for the motor,
	 * or E_GEARSET_INVALID if the operation failed.
	 */ 1385 2 1395 5 18446744073709551615 3 std 1396 2 1396 5 2 2 :: 1396 5 1396 7 155 6 vector 1396 7 1396 13 106 1 < 1396 13 1396 14 155 17 motor_gearset_e_t 1396 14 1396 31 4 1 > 1396 31 1396 32 155 11 get_gearing 1396 33 1396 44 155 1 ( 1396 44 1396 45 155 4 void 1396 45 1396 49 18446744073709551615 1 ) 1396 49 1396 50 155 1 ; 1396 50 1396 51 18446744073709551615 403 /**
	 * Gets the current drawn by each motor in mA.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \return A vector containing each motor's current in mA
	 * or a vector filled with PROS_ERR if the operation failed, setting errno.
	 */ 1398 2 1408 5 18446744073709551615 3 std 1409 2 1409 5 2 2 :: 1409 5 1409 7 156 6 vector 1409 7 1409 13 106 1 < 1409 13 1409 14 156 3 std 1409 14 1409 17 2 2 :: 1409 17 1409 19 156 7 int32_t 1409 19 1409 26 156 1 > 1409 26 1409 27 156 17 get_current_draws 1409 28 1409 45 156 1 ( 1409 45 1409 46 156 4 void 1409 46 1409 50 18446744073709551615 1 ) 1409 50 1409 51 156 1 ; 1409 51 1409 52 18446744073709551615 442 /**
	 * Gets the current limit for each motor in mA.
	 *
	 * The default value is 2500 mA.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \return A vector with each motor's current limit in mA or a vector filled
	 * with PROS_ERR if the operation failed, setting errno.
	 */ 1411 2 1423 5 18446744073709551615 3 std 1424 2 1424 5 2 2 :: 1424 5 1424 7 157 6 vector 1424 7 1424 13 106 1 < 1424 13 1424 14 157 3 std 1424 14 1424 17 2 2 :: 1424 17 1424 19 157 7 int32_t 1424 19 1424 26 157 1 > 1424 26 1424 27 157 18 get_current_limits 1424 28 1424 46 157 1 ( 1424 46 1424 47 157 4 void 1424 47 1424 51 18446744073709551615 1 ) 1424 51 1424 52 157 1 ; 1424 52 1424 53 18446744073709551615 104 /**
	 * Gets the port number of each motor.
	 *
	 * \return a vector with each motor's port number.
	 */ 1426 2 1430 5 18446744073709551615 3 std 1431 2 1431 5 2 2 :: 1431 5 1431 7 158 6 vector 1431 7 1431 13 106 1 < 1431 13 1431 14 158 3 std 1431 14 1431 17 2 2 :: 1431 17 1431 19 158 7 uint8_t 1431 19 1431 26 158 1 > 1431 26 1431 27 158 9 get_ports 1431 28 1431 37 158 1 ( 1431 37 1431 38 158 4 void 1431 38 1431 42 18446744073709551615 1 ) 1431 42 1431 43 158 1 ; 1431 43 1431 44 18446744073709551615 360 /**
	 * Gets the direction of movement for the motors.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 *
	 * \return 1 for moving in the positive direction, -1 for moving in the
	 * negative direction, and PROS_ERR if the operation failed, setting errno.
	 */ 1432 2 1441 5 18446744073709551615 3 std 1442 2 1442 5 2 2 :: 1442 5 1442 7 159 6 vector 1442 7 1442 13 106 1 < 1442 13 1442 14 159 3 std 1442 14 1442 17 2 2 :: 1442 17 1442 19 159 7 int32_t 1442 19 1442 26 159 1 > 1442 26 1442 27 159 14 get_directions 1442 28 1442 42 159 1 ( 1442 42 1442 43 159 4 void 1442 43 1442 47 18446744073709551615 1 ) 1442 47 1442 48 159 1 ; 1442 48 1442 49 18446744073709551615 475 /**
	 * Gets the encoder units that were set for each motor.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \return A vector filled with one of motor_encoder_units_e_t for each motor
	 * according to what is set for the motor or a vector filled with
	 * E_MOTOR_ENCODER_INVALID if the operation failed.
	 */ 1444 2 1455 5 18446744073709551615 3 std 1456 2 1456 5 2 2 :: 1456 5 1456 7 160 6 vector 1456 7 1456 13 106 1 < 1456 13 1456 14 160 4 pros 1456 14 1456 18 0 2 :: 1456 18 1456 20 160 23 motor_encoder_units_e_t 1456 20 1456 43 7 1 > 1456 43 1456 44 160 17 get_encoder_units 1456 45 1456 62 160 1 ( 1456 62 1456 63 160 4 void 1456 63 1456 67 18446744073709551615 1 ) 1456 67 1456 68 160 1 ; 1456 68 1456 69 18446744073709551615 409 /**
	 * Gets the encoder units that were set for each motor.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENODEV - The port cannot be configured as a motor
	 * EACCESS - The Motor group mutex can't be taken or given
	 *
	 * \return The vector filled with motors' temperature in degrees Celsius or PROS_ERR_F if the
 	 * operation failed, setting errno.
	 */ 1458 2 1468 5 18446744073709551615 7 virtual 1469 2 1469 9 18446744073709551615 3 std 1469 10 1469 13 2 2 :: 1469 13 1469 15 161 6 vector 1469 15 1469 21 106 1 < 1469 21 1469 22 161 6 double 1469 22 1469 28 18446744073709551615 1 > 1469 28 1469 29 161 16 get_temperatures 1469 30 1469 46 161 1 ( 1469 46 1469 47 161 4 void 1469 47 1469 51 18446744073709551615 1 ) 1469 51 1469 52 161 1 ; 1469 52 1469 53 18446744073709551615 7 private 1471 2 1471 9 18446744073709551615 1 : 1471 9 1471 10 18446744073709551615 3 std 1472 2 1472 5 2 2 :: 1472 5 1472 7 18446744073709551615 6 vector 1472 7 1472 13 106 1 < 1472 13 1472 14 18446744073709551615 5 Motor 1472 14 1472 19 1 1 > 1472 19 1472 20 18446744073709551615 7 _motors 1472 21 1472 28 162 1 ; 1472 28 1472 29 18446744073709551615 4 pros 1473 2 1473 6 0 2 :: 1473 6 1473 8 18446744073709551615 5 Mutex 1473 8 1473 13 163 18 _motor_group_mutex 1473 14 1473 32 164 1 ; 1473 32 1473 33 18446744073709551615 3 std 1474 2 1474 5 2 2 :: 1474 5 1474 7 18446744073709551615 7 uint8_t 1474 7 1474 14 165 12 _motor_count 1474 15 1474 27 165 1 ; 1474 27 1474 28 18446744073709551615 1 } 1475 1 1475 2 18446744073709551615 1 ; 1475 2 1475 3 18446744073709551615 5 using 1477 1 1477 6 18446744073709551615 10 MotorGroup 1477 7 1477 17 166 1 = 1477 18 1477 19 18446744073709551615 11 Motor_Group 1477 20 1477 31 103 1 ; 1477 31 1477 32 18446744073709551615 7 //alias 1477 33 1477 40 18446744073709551615 9 namespace 1479 1 1479 10 18446744073709551615 8 literals 1479 11 1479 19 167 1 { 1479 20 1479 21 18446744073709551615 5 const 1480 1 1480 6 18446744073709551615 4 pros 1480 7 1480 11 0 2 :: 1480 11 1480 13 168 5 Motor 1480 13 1480 18 1 8 operator 1480 19 1480 27 168 2 "" 1480 27 1480 29 18446744073709551615 4 _mtr 1480 30 1480 34 168 1 ( 1480 34 1480 35 168 5 const 1480 35 1480 40 18446744073709551615 8 unsigned 1480 41 1480 49 18446744073709551615 4 long 1480 50 1480 54 18446744073709551615 4 long 1480 55 1480 59 18446744073709551615 3 int 1480 60 1480 63 18446744073709551615 1 m 1480 64 1480 65 169 1 ) 1480 65 1480 66 168 1 ; 1480 66 1480 67 18446744073709551615 5 const 1481 1 1481 6 18446744073709551615 4 pros 1481 7 1481 11 0 2 :: 1481 11 1481 13 170 5 Motor 1481 13 1481 18 1 8 operator 1481 19 1481 27 170 2 "" 1481 27 1481 29 18446744073709551615 5 _rmtr 1481 30 1481 35 170 1 ( 1481 35 1481 36 170 5 const 1481 36 1481 41 18446744073709551615 8 unsigned 1481 42 1481 50 18446744073709551615 4 long 1481 51 1481 55 18446744073709551615 4 long 1481 56 1481 60 18446744073709551615 3 int 1481 61 1481 64 18446744073709551615 1 m 1481 65 1481 66 171 1 ) 1481 66 1481 67 170 1 ; 1481 67 1481 68 18446744073709551615 1 } 1482 1 1482 2 18446744073709551615 21 // namespace literals 1482 4 1482 25 18446744073709551615 1 } 1483 1 1483 2 18446744073709551615 17 // namespace pros 1483 4 1483 21 18446744073709551615 1 # 1484 1 1484 2 18446744073709551615 5 endif 1484 2 1484 7 18446744073709551615 20 // _PROS_MOTORS_HPP_ 1484 9 1484 29 18446744073709551615 0 0 172 0 0 0 22 0 0 1 13 0 4 pros 4 1 13 0 10 Motor:pros 22 1 13 0 3 std 10 1 13 0 70 49:35:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 20 1 13 0 22 motor_gearset_e_t:pros 10 1 13 0 70 49:65:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 70 49:85:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 20 1 13 0 28 motor_encoder_units_e_t:pros 10 1 13 0 70 50:47:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 70 52:35:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 70 52:65:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 70 52:85:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 70 54:35:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 70 54:65:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 70 56:35:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 70 56:52:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 70 58:35:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 20 operator=:Motor:pros 10 1 13 0 70 82:46:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 15 move:Motor:pros 10 1 13 0 71 101:41:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 24 move_absolute:Motor:pros 10 1 13 0 71 125:50:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 71 125:79:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 24 move_relative:Motor:pros 10 1 13 0 71 150:50:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 71 150:79:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 24 move_velocity:Motor:pros 10 1 13 0 71 172:56:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 23 move_voltage:Motor:pros 10 1 13 0 71 187:55:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 16 brake:Motor:pros 21 1 13 0 35 modify_profiled_velocity:Motor:pros 10 1 13 0 71 222:67:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 30 get_target_position:Motor:pros 21 1 13 0 30 get_target_velocity:Motor:pros 21 1 13 0 30 get_actual_velocity:Motor:pros 21 1 13 0 27 get_current_draw:Motor:pros 21 1 13 0 24 get_direction:Motor:pros 21 1 13 0 25 get_efficiency:Motor:pros 21 1 13 0 26 is_over_current:Motor:pros 21 1 13 0 21 is_stopped:Motor:pros 21 1 13 0 33 get_zero_position_flag:Motor:pros 21 1 13 0 21 get_faults:Motor:pros 21 1 13 0 20 get_flags:Motor:pros 21 1 13 0 27 get_raw_position:Motor:pros 10 1 13 0 71 393:61:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 23 is_over_temp:Motor:pros 21 1 13 0 23 get_position:Motor:pros 21 1 13 0 20 get_power:Motor:pros 21 1 13 0 26 get_temperature:Motor:pros 21 1 13 0 21 get_torque:Motor:pros 21 1 13 0 22 get_voltage:Motor:pros 21 1 13 0 28 set_zero_position:Motor:pros 10 1 13 0 71 490:54:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 24 tare_position:Motor:pros 21 1 13 0 25 set_brake_mode:Motor:pros 20 1 13 0 25 motor_brake_mode_e_t:pros 10 1 13 0 71 517:65:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 28 set_current_limit:Motor:pros 10 1 13 0 71 532:60:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 28 set_encoder_units:Motor:pros 10 1 13 0 71 547:71:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 22 set_gearing:Motor:pros 10 1 13 0 71 562:59:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 20 1 13 0 18 motor_pid_s_t:pros 21 1 13 0 22 convert_pid:Motor:pros 10 1 13 0 71 584:21:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 71 584:32:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 71 584:43:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 71 584:54:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 20 1 13 0 23 motor_pid_full_s_t:pros 21 1 13 0 27 convert_pid_full:Motor:pros 10 1 13 0 71 616:26:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 71 616:37:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 71 616:48:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 71 616:59:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 71 616:70:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 71 616:85:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 71 616:99:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 71 617:26:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 22 set_pos_pid:Motor:pros 10 1 13 0 71 638:34:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 27 set_pos_pid_full:Motor:pros 10 1 13 0 71 658:44:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 22 set_vel_pid:Motor:pros 10 1 13 0 71 679:34:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 27 set_vel_pid_full:Motor:pros 10 1 13 0 71 699:44:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 23 set_reversed:Motor:pros 10 1 13 0 71 716:47:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 28 set_voltage_limit:Motor:pros 10 1 13 0 71 731:60:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 25 get_brake_mode:Motor:pros 21 1 13 0 28 get_current_limit:Motor:pros 21 1 13 0 28 get_encoder_units:Motor:pros 21 1 13 0 22 get_gearing:Motor:pros 21 1 13 0 22 get_pos_pid:Motor:pros 21 1 13 0 22 get_vel_pid:Motor:pros 21 1 13 0 22 is_reversed:Motor:pros 21 1 13 0 28 get_voltage_limit:Motor:pros 21 1 13 0 19 get_port:Motor:pros 6 1 13 0 16 _port:Motor:pros 4 1 13 0 16 Motor_Group:pros 31 1 13 0 20 initializer_list:std 10 1 13 0 71 863:49:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 31 1 13 0 10 vector:std 10 1 13 0 71 864:55:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 71 865:64:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 71 866:54:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 26 operator=:Motor_Group:pros 10 1 13 0 71 891:37:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 21 move:Motor_Group:pros 10 1 13 0 71 912:33:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 30 move_absolute:Motor_Group:pros 10 1 13 0 71 937:42:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 71 937:71:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 30 move_relative:Motor_Group:pros 10 1 13 0 71 963:42:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 10 1 13 0 71 963:71:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 30 move_velocity:Motor_Group:pros 10 1 13 0 71 986:48:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 29 move_voltage:Motor_Group:pros 10 1 13 0 72 1002:47:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 22 brake:Motor_Group:pros 21 1 13 0 29 get_voltages:Motor_Group:pros 21 1 13 0 35 get_voltage_limits:Motor_Group:pros 21 1 13 0 34 get_raw_positions:Motor_Group:pros 10 1 13 0 72 1115:75:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 27 operator[]:Motor_Group:pros 10 1 13 0 72 1135:30:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 19 at:Motor_Group:pros 10 1 13 0 72 1150:22:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 21 size:Motor_Group:pros 21 1 13 0 34 set_zero_position:Motor_Group:pros 10 1 13 0 72 1176:46:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 32 set_brake_modes:Motor_Group:pros 10 1 13 0 72 1191:52:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 29 set_reversed:Motor_Group:pros 10 1 13 0 72 1209:39:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 34 set_voltage_limit:Motor_Group:pros 10 1 13 0 72 1225:52:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 28 set_gearing:Motor_Group:pros 10 1 13 0 72 1240:51:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 34 set_encoder_units:Motor_Group:pros 10 1 13 0 72 1257:63:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 21 1 13 0 30 tare_position:Motor_Group:pros 21 1 13 0 38 get_actual_velocities:Motor_Group:pros 21 1 13 0 38 get_target_velocities:Motor_Group:pros 21 1 13 0 37 get_target_positions:Motor_Group:pros 21 1 13 0 30 get_positions:Motor_Group:pros 21 1 13 0 33 get_efficiencies:Motor_Group:pros 21 1 13 0 33 are_over_current:Motor_Group:pros 21 1 13 0 30 are_over_temp:Motor_Group:pros 21 1 13 0 32 get_brake_modes:Motor_Group:pros 21 1 13 0 28 get_gearing:Motor_Group:pros 21 1 13 0 34 get_current_draws:Motor_Group:pros 21 1 13 0 35 get_current_limits:Motor_Group:pros 21 1 13 0 26 get_ports:Motor_Group:pros 21 1 13 0 31 get_directions:Motor_Group:pros 21 1 13 0 34 get_encoder_units:Motor_Group:pros 21 1 13 0 33 get_temperatures:Motor_Group:pros 6 1 13 0 24 _motors:Motor_Group:pros 4 1 13 0 10 Mutex:pros 6 1 13 0 35 _motor_group_mutex:Motor_Group:pros 6 1 13 0 29 _motor_count:Motor_Group:pros 36 1 13 0 15 MotorGroup:pros 22 1 13 0 13 literals:pros 8 1 13 0 28 operator""_mtr:literals:pros 10 1 13 0 72 1480:64:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 8 1 13 0 29 operator""_rmtr:literals:pros 10 1 13 0 72 1481:65:/home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 0 0 2 0 0 0 64 /home/bluecore/Desktop/Pros/Main Project/include/pros/motors.hpp 1698321184 62 /home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 1698321186