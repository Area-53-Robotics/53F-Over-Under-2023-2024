22 serialization::archive 19 0 0 0 0 40 /home/bluecore/Desktop/Pros/Main Project 40 /home/bluecore/Desktop/Pros/Main Project 0 0 1218 0 0 0 629 /**
 * \file pros/rtos.hpp
 *
 * Contains declarations for the PROS RTOS kernel for use by typical VEX
 * programmers.
 *
 * Visit https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html to
 * learn more.
 *
 * This file should not be modified by users, since it gets replaced whenever
 * a kernel upgrade occurs.
 *
 * \copyright Copyright (c) 2017-2023, Purdue University ACM SIGBots.
 * All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */ 1 1 19 4 18446744073709551615 1 # 21 1 21 2 18446744073709551615 6 ifndef 21 2 21 8 18446744073709551615 15 _PROS_RTOS_HPP_ 21 9 21 24 18446744073709551615 1 # 22 1 22 2 18446744073709551615 6 define 22 2 22 8 18446744073709551615 15 _PROS_RTOS_HPP_ 22 9 22 24 18446744073709551615 1 # 24 1 24 2 18446744073709551615 7 include 24 2 24 9 18446744073709551615 13 "pros/rtos.h" 24 10 24 23 18446744073709551615 1 # 25 1 25 2 18446744073709551615 5 undef 25 2 25 7 18446744073709551615 5 delay 25 8 25 13 18446744073709551615 1 # 26 1 26 2 18446744073709551615 7 include 26 2 26 9 18446744073709551615 1 < 26 10 26 11 18446744073709551615 6 chrono 26 11 26 17 18446744073709551615 1 > 26 17 26 18 18446744073709551615 1 # 27 1 27 2 18446744073709551615 7 include 27 2 27 9 18446744073709551615 1 < 27 10 27 11 18446744073709551615 7 cstdint 27 11 27 18 18446744073709551615 1 > 27 18 27 19 18446744073709551615 1 # 28 1 28 2 18446744073709551615 7 include 28 2 28 9 18446744073709551615 1 < 28 10 28 11 18446744073709551615 7 cstdlib 28 11 28 18 18446744073709551615 1 > 28 18 28 19 18446744073709551615 1 # 29 1 29 2 18446744073709551615 7 include 29 2 29 9 18446744073709551615 1 < 29 10 29 11 18446744073709551615 10 functional 29 11 29 21 18446744073709551615 1 > 29 21 29 22 18446744073709551615 1 # 30 1 30 2 18446744073709551615 7 include 30 2 30 9 18446744073709551615 1 < 30 10 30 11 18446744073709551615 6 memory 30 11 30 17 18446744073709551615 1 > 30 17 30 18 18446744073709551615 1 # 31 1 31 2 18446744073709551615 7 include 31 2 31 9 18446744073709551615 1 < 31 10 31 11 18446744073709551615 8 optional 31 11 31 19 18446744073709551615 1 > 31 19 31 20 18446744073709551615 1 # 32 1 32 2 18446744073709551615 7 include 32 2 32 9 18446744073709551615 1 < 32 10 32 11 18446744073709551615 11 type_traits 32 11 32 22 18446744073709551615 1 > 32 22 32 23 18446744073709551615 9 namespace 34 1 34 10 18446744073709551615 4 pros 34 11 34 15 0 1 { 34 16 34 17 18446744073709551615 5 class 35 1 35 6 18446744073709551615 4 Task 35 7 35 11 1 1 { 35 12 35 13 18446744073709551615 6 public 36 2 36 8 18446744073709551615 1 : 36 8 36 9 18446744073709551615 1056 /**
	 * Creates a new task and add it to the list of tasks that are ready to run.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENOMEM - The stack cannot be used as the TCB was not created.
	 *
	 * \param function
	 *        Pointer to the task entry function
	 * \param parameters
	 *        Pointer to memory that will be used as a parameter for the task
	 *        being created. This memory should not typically come from stack,
	 *        but rather from dynamically (i.e., malloc'd) or statically
	 *        allocated memory.
	 * \param prio
	 *        The priority at which the task should run.
	 *        TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used.
	 * \param stack_depth
	 *        The number of words (i.e. 4 * stack_depth) available on the task's
	 *        stack. TASK_STACK_DEPTH_DEFAULT is typically sufficienct.
	 * \param name
	 *        A descriptive name for the task.  This is mainly used to facilitate
	 *        debugging. The name may be up to 32 characters long.
	 *
	 */ 37 2 61 5 18446744073709551615 4 Task 62 2 62 6 1 1 ( 62 6 62 7 1 9 task_fn_t 62 7 62 16 2 8 function 62 17 62 25 3 1 , 62 25 62 26 1 4 void 62 27 62 31 18446744073709551615 1 * 62 31 62 32 18446744073709551615 10 parameters 62 33 62 43 4 1 = 62 44 62 45 18446744073709551615 7 nullptr 62 46 62 53 18446744073709551615 1 , 62 53 62 54 1 3 std 62 55 62 58 5 2 :: 62 58 62 60 18446744073709551615 8 uint32_t 62 60 62 68 6 4 prio 62 69 62 73 6 1 = 62 74 62 75 18446744073709551615 21 TASK_PRIORITY_DEFAULT 62 76 62 97 6 1 , 62 97 62 98 1 3 std 63 7 63 10 5 2 :: 63 10 63 12 18446744073709551615 8 uint16_t 63 12 63 20 7 11 stack_depth 63 21 63 32 7 1 = 63 33 63 34 18446744073709551615 24 TASK_STACK_DEPTH_DEFAULT 63 35 63 59 7 1 , 63 59 63 60 1 5 const 63 61 63 66 18446744073709551615 4 char 63 67 63 71 18446744073709551615 1 * 63 71 63 72 18446744073709551615 4 name 63 73 63 77 8 1 = 63 78 63 79 18446744073709551615 2 "" 63 80 63 82 18446744073709551615 1 ) 63 82 63 83 1 1 ; 63 83 63 84 18446744073709551615 750 /**
	 * Creates a new task and add it to the list of tasks that are ready to run.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENOMEM - The stack cannot be used as the TCB was not created.
	 *
	 * \param function
	 *        Pointer to the task entry function
	 * \param parameters
	 *        Pointer to memory that will be used as a parameter for the task
	 *        being created. This memory should not typically come from stack,
	 *        but rather from dynamically (i.e., malloc'd) or statically
	 *        allocated memory.
	 * \param name
	 *        A descriptive name for the task.  This is mainly used to facilitate
	 *        debugging. The name may be up to 32 characters long.
	 *
	 */ 65 2 83 5 18446744073709551615 4 Task 84 2 84 6 1 1 ( 84 6 84 7 1 9 task_fn_t 84 7 84 16 2 8 function 84 17 84 25 9 1 , 84 25 84 26 1 4 void 84 27 84 31 18446744073709551615 1 * 84 31 84 32 18446744073709551615 10 parameters 84 33 84 43 10 1 , 84 43 84 44 1 5 const 84 45 84 50 18446744073709551615 4 char 84 51 84 55 18446744073709551615 1 * 84 55 84 56 18446744073709551615 4 name 84 57 84 61 11 1 ) 84 61 84 62 1 1 ; 84 62 84 63 18446744073709551615 790 /**
	 * Creates a new task and add it to the list of tasks that are ready to run.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENOMEM - The stack cannot be used as the TCB was not created.
	 *
	 * \param function
	 *        Callable object to use as entry function
	 * \param prio
	 *        The priority at which the task should run.
	 *        TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used.
	 * \param stack_depth
	 *        The number of words (i.e. 4 * stack_depth) available on the task's
	 *        stack. TASK_STACK_DEPTH_DEFAULT is typically sufficienct.
	 * \param name
	 *        A descriptive name for the task.  This is mainly used to facilitate
	 *        debugging. The name may be up to 32 characters long.
	 *
	 */ 86 2 105 5 18446744073709551615 8 template 106 2 106 10 18446744073709551615 1 < 106 11 106 12 18446744073709551615 5 class 106 12 106 17 18446744073709551615 1 F 106 18 106 19 12 1 > 106 19 106 20 18446744073709551615 6 static 107 2 107 8 18446744073709551615 6 task_t 107 9 107 15 13 6 create 107 16 107 22 14 1 ( 107 22 107 23 18446744073709551615 1 F 107 23 107 24 12 2 && 107 24 107 26 18446744073709551615 8 function 107 27 107 35 15 1 , 107 35 107 36 18446744073709551615 3 std 107 37 107 40 5 2 :: 107 40 107 42 18446744073709551615 8 uint32_t 107 42 107 50 16 4 prio 107 51 107 55 16 1 = 107 56 107 57 18446744073709551615 21 TASK_PRIORITY_DEFAULT 107 58 107 79 16 1 , 107 79 107 80 18446744073709551615 3 std 108 23 108 26 5 2 :: 108 26 108 28 18446744073709551615 8 uint16_t 108 28 108 36 17 11 stack_depth 108 37 108 48 17 1 = 108 49 108 50 18446744073709551615 24 TASK_STACK_DEPTH_DEFAULT 108 51 108 75 17 1 , 108 75 108 76 18446744073709551615 5 const 108 77 108 82 18446744073709551615 4 char 108 83 108 87 18446744073709551615 1 * 108 87 108 88 18446744073709551615 4 name 108 89 108 93 18 1 = 108 94 108 95 18446744073709551615 2 "" 108 96 108 98 18446744073709551615 1 ) 108 98 108 99 18446744073709551615 1 { 108 100 108 101 18446744073709551615 13 static_assert 109 3 109 16 18446744073709551615 1 ( 109 16 109 17 18446744073709551615 3 std 109 17 109 20 5 2 :: 109 20 109 22 18446744073709551615 16 is_invocable_r_v 109 22 109 38 19 1 < 109 38 109 39 18446744073709551615 4 void 109 39 109 43 18446744073709551615 1 , 109 43 109 44 18446744073709551615 1 F 109 45 109 46 12 1 > 109 46 109 47 18446744073709551615 1 ) 109 47 109 48 18446744073709551615 1 ; 109 48 109 49 18446744073709551615 6 return 110 3 110 9 18446744073709551615 4 pros 110 10 110 14 0 2 :: 110 14 110 16 20 1 c 110 16 110 17 21 2 :: 110 17 110 19 20 11 task_create 110 19 110 30 20 1 ( 110 30 110 31 20 1 [ 111 7 111 8 18446744073709551615 1 ] 111 8 111 9 18446744073709551615 1 ( 111 9 111 10 18446744073709551615 4 void 111 10 111 14 18446744073709551615 1 * 111 14 111 15 18446744073709551615 10 parameters 111 16 111 26 22 1 ) 111 26 111 27 18446744073709551615 1 { 111 28 111 29 18446744073709551615 3 std 112 8 112 11 5 2 :: 112 11 112 13 18446744073709551615 10 unique_ptr 112 13 112 23 23 1 < 112 23 112 24 18446744073709551615 3 std 112 24 112 27 5 2 :: 112 27 112 29 18446744073709551615 8 function 112 29 112 37 24 1 < 112 37 112 38 18446744073709551615 4 void 112 38 112 42 18446744073709551615 1 ( 112 42 112 43 18446744073709551615 1 ) 112 43 112 44 18446744073709551615 2 >> 112 44 112 46 18446744073709551615 3 ptr 112 47 112 50 25 1 { 112 50 112 51 23 11 static_cast 112 51 112 62 18446744073709551615 1 < 112 62 112 63 18446744073709551615 3 std 112 63 112 66 5 2 :: 112 66 112 68 18446744073709551615 8 function 112 68 112 76 24 1 < 112 76 112 77 18446744073709551615 4 void 112 77 112 81 18446744073709551615 1 ( 112 81 112 82 18446744073709551615 1 ) 112 82 112 83 18446744073709551615 1 > 112 83 112 84 18446744073709551615 1 * 112 84 112 85 18446744073709551615 1 > 112 85 112 86 18446744073709551615 1 ( 112 86 112 87 18446744073709551615 10 parameters 112 87 112 97 22 1 ) 112 97 112 98 18446744073709551615 1 } 112 98 112 99 23 1 ; 112 99 112 100 18446744073709551615 1 ( 113 8 113 9 18446744073709551615 1 * 113 9 113 10 26 3 ptr 113 10 113 13 25 1 ) 113 13 113 14 18446744073709551615 1 ( 113 14 113 15 27 1 ) 113 15 113 16 27 1 ; 113 16 113 17 18446744073709551615 1 } 114 7 114 8 18446744073709551615 1 , 114 8 114 9 20 3 new 115 7 115 10 18446744073709551615 3 std 115 11 115 14 5 2 :: 115 14 115 16 18446744073709551615 8 function 115 16 115 24 24 1 < 115 24 115 25 18446744073709551615 4 void 115 25 115 29 18446744073709551615 1 ( 115 29 115 30 18446744073709551615 1 ) 115 30 115 31 18446744073709551615 1 > 115 31 115 32 18446744073709551615 1 ( 115 32 115 33 18446744073709551615 3 std 115 33 115 36 5 2 :: 115 36 115 38 18446744073709551615 7 forward 115 38 115 45 28 1 < 115 45 115 46 18446744073709551615 1 F 115 46 115 47 12 1 > 115 47 115 48 18446744073709551615 1 ( 115 48 115 49 18446744073709551615 8 function 115 49 115 57 15 1 ) 115 57 115 58 18446744073709551615 1 ) 115 58 115 59 18446744073709551615 1 , 115 59 115 60 20 4 prio 115 61 115 65 16 1 , 115 65 115 66 20 11 stack_depth 115 67 115 78 17 1 , 115 78 115 79 20 4 name 115 80 115 84 18 1 ) 115 84 115 85 20 1 ; 115 85 115 86 18446744073709551615 1 } 116 2 116 3 18446744073709551615 484 /**
	 * Creates a new task and add it to the list of tasks that are ready to run.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENOMEM - The stack cannot be used as the TCB was not created.
	 *
	 * \param function
	 *        Callable object to use as entry function
	 * \param name
	 *        A descriptive name for the task.  This is mainly used to facilitate
	 *        debugging. The name may be up to 32 characters long.
	 *
	 */ 118 2 131 5 18446744073709551615 8 template 132 2 132 10 18446744073709551615 1 < 132 11 132 12 18446744073709551615 5 class 132 12 132 17 18446744073709551615 1 F 132 18 132 19 29 1 > 132 19 132 20 18446744073709551615 6 static 133 2 133 8 18446744073709551615 6 task_t 133 9 133 15 13 6 create 133 16 133 22 14 1 ( 133 22 133 23 18446744073709551615 1 F 133 23 133 24 29 2 && 133 24 133 26 18446744073709551615 8 function 133 27 133 35 30 1 , 133 35 133 36 18446744073709551615 5 const 133 37 133 42 18446744073709551615 4 char 133 43 133 47 18446744073709551615 1 * 133 47 133 48 18446744073709551615 4 name 133 49 133 53 31 1 ) 133 53 133 54 18446744073709551615 1 { 133 55 133 56 18446744073709551615 6 return 134 3 134 9 18446744073709551615 4 Task 134 10 134 14 1 2 :: 134 14 134 16 18446744073709551615 6 create 134 16 134 22 32 1 ( 134 22 134 23 18446744073709551615 3 std 134 23 134 26 5 2 :: 134 26 134 28 18446744073709551615 7 forward 134 28 134 35 28 1 < 134 35 134 36 18446744073709551615 1 F 134 36 134 37 29 1 > 134 37 134 38 18446744073709551615 1 ( 134 38 134 39 18446744073709551615 8 function 134 39 134 47 30 1 ) 134 47 134 48 18446744073709551615 1 , 134 48 134 49 18446744073709551615 21 TASK_PRIORITY_DEFAULT 134 50 134 71 18446744073709551615 1 , 134 71 134 72 18446744073709551615 24 TASK_STACK_DEPTH_DEFAULT 134 73 134 97 18446744073709551615 1 , 134 97 134 98 18446744073709551615 4 name 134 99 134 103 31 1 ) 134 103 134 104 18446744073709551615 1 ; 134 104 134 105 18446744073709551615 1 } 135 2 135 3 18446744073709551615 789 /**
	 * Creates a new task and add it to the list of tasks that are ready to run.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENOMEM - The stack cannot be used as the TCB was not created.
	 *
	 * \param function
	 *        Callable object to use as entry function
	 * \param prio
	 *        The priority at which the task should run.
	 *        TASK_PRIO_DEFAULT plus/minus 1 or 2 is typically used.
	 * \param stack_depth
	 *        The number of words (i.e. 4 * stack_depth) available on the task's
	 *        stack. TASK_STACK_DEPTH_DEFAULT is typically sufficient.
	 * \param name
	 *        A descriptive name for the task.  This is mainly used to facilitate
	 *        debugging. The name may be up to 32 characters long.
	 *
	 */ 137 2 156 5 18446744073709551615 8 template 157 2 157 10 18446744073709551615 1 < 157 11 157 12 18446744073709551615 5 class 157 12 157 17 18446744073709551615 1 F 157 18 157 19 33 1 > 157 19 157 20 18446744073709551615 8 explicit 158 2 158 10 18446744073709551615 4 Task 158 11 158 15 1 1 ( 158 15 158 16 18446744073709551615 1 F 158 16 158 17 33 2 && 158 17 158 19 18446744073709551615 8 function 158 20 158 28 34 1 , 158 28 158 29 18446744073709551615 3 std 158 30 158 33 5 2 :: 158 33 158 35 18446744073709551615 8 uint32_t 158 35 158 43 35 4 prio 158 44 158 48 35 1 = 158 49 158 50 18446744073709551615 21 TASK_PRIORITY_DEFAULT 158 51 158 72 35 1 , 158 72 158 73 18446744073709551615 3 std 159 16 159 19 5 2 :: 159 19 159 21 18446744073709551615 8 uint16_t 159 21 159 29 36 11 stack_depth 159 30 159 41 36 1 = 159 42 159 43 18446744073709551615 24 TASK_STACK_DEPTH_DEFAULT 159 44 159 68 36 1 , 159 68 159 69 18446744073709551615 5 const 159 70 159 75 18446744073709551615 4 char 159 76 159 80 18446744073709551615 1 * 159 80 159 81 18446744073709551615 4 name 159 82 159 86 37 1 = 159 87 159 88 18446744073709551615 2 "" 159 89 159 91 18446744073709551615 1 ) 159 91 159 92 18446744073709551615 1 : 160 6 160 7 18446744073709551615 4 Task 160 8 160 12 1 1 ( 160 12 160 13 18446744073709551615 1 [ 161 12 161 13 18446744073709551615 1 ] 161 13 161 14 18446744073709551615 1 ( 161 14 161 15 18446744073709551615 4 void 161 15 161 19 18446744073709551615 1 * 161 19 161 20 18446744073709551615 10 parameters 161 21 161 31 38 1 ) 161 31 161 32 18446744073709551615 1 { 161 33 161 34 18446744073709551615 3 std 162 13 162 16 5 2 :: 162 16 162 18 18446744073709551615 10 unique_ptr 162 18 162 28 23 1 < 162 28 162 29 18446744073709551615 3 std 162 29 162 32 5 2 :: 162 32 162 34 18446744073709551615 8 function 162 34 162 42 24 1 < 162 42 162 43 18446744073709551615 4 void 162 43 162 47 18446744073709551615 1 ( 162 47 162 48 18446744073709551615 1 ) 162 48 162 49 18446744073709551615 2 >> 162 49 162 51 18446744073709551615 3 ptr 162 52 162 55 39 1 { 162 55 162 56 23 11 static_cast 162 56 162 67 18446744073709551615 1 < 162 67 162 68 18446744073709551615 3 std 162 68 162 71 5 2 :: 162 71 162 73 18446744073709551615 8 function 162 73 162 81 24 1 < 162 81 162 82 18446744073709551615 4 void 162 82 162 86 18446744073709551615 1 ( 162 86 162 87 18446744073709551615 1 ) 162 87 162 88 18446744073709551615 1 > 162 88 162 89 18446744073709551615 1 * 162 89 162 90 18446744073709551615 1 > 162 90 162 91 18446744073709551615 1 ( 162 91 162 92 18446744073709551615 10 parameters 162 92 162 102 38 1 ) 162 102 162 103 18446744073709551615 1 } 162 103 162 104 23 1 ; 162 104 162 105 18446744073709551615 1 ( 163 13 163 14 18446744073709551615 1 * 163 14 163 15 26 3 ptr 163 15 163 18 39 1 ) 163 18 163 19 18446744073709551615 1 ( 163 19 163 20 27 1 ) 163 20 163 21 27 1 ; 163 21 163 22 18446744073709551615 1 } 164 12 164 13 18446744073709551615 1 , 164 13 164 14 18446744073709551615 3 new 165 12 165 15 18446744073709551615 3 std 165 16 165 19 5 2 :: 165 19 165 21 18446744073709551615 8 function 165 21 165 29 24 1 < 165 29 165 30 18446744073709551615 4 void 165 30 165 34 18446744073709551615 1 ( 165 34 165 35 18446744073709551615 1 ) 165 35 165 36 18446744073709551615 1 > 165 36 165 37 18446744073709551615 1 ( 165 37 165 38 18446744073709551615 3 std 165 38 165 41 5 2 :: 165 41 165 43 18446744073709551615 7 forward 165 43 165 50 28 1 < 165 50 165 51 18446744073709551615 1 F 165 51 165 52 33 1 > 165 52 165 53 18446744073709551615 1 ( 165 53 165 54 18446744073709551615 8 function 165 54 165 62 34 1 ) 165 62 165 63 18446744073709551615 1 ) 165 63 165 64 18446744073709551615 1 , 165 64 165 65 18446744073709551615 4 prio 165 66 165 70 35 1 , 165 70 165 71 18446744073709551615 11 stack_depth 165 72 165 83 36 1 , 165 83 165 84 18446744073709551615 4 name 165 85 165 89 37 1 ) 165 89 165 90 18446744073709551615 1 { 165 91 165 92 18446744073709551615 13 static_assert 166 3 166 16 18446744073709551615 1 ( 166 16 166 17 18446744073709551615 3 std 166 17 166 20 5 2 :: 166 20 166 22 18446744073709551615 16 is_invocable_r_v 166 22 166 38 19 1 < 166 38 166 39 18446744073709551615 4 void 166 39 166 43 18446744073709551615 1 , 166 43 166 44 18446744073709551615 1 F 166 45 166 46 33 1 > 166 46 166 47 18446744073709551615 1 ) 166 47 166 48 18446744073709551615 1 ; 166 48 166 49 18446744073709551615 1 } 167 2 167 3 18446744073709551615 484 /**
	 * Creates a new task and add it to the list of tasks that are ready to run.
	 *
	 * This function uses the following values of errno when an error state is
	 * reached:
	 * ENOMEM - The stack cannot be used as the TCB was not created.
	 *
	 * \param function
	 *        Callable object to use as entry function
	 * \param name
	 *        A descriptive name for the task.  This is mainly used to facilitate
	 *        debugging. The name may be up to 32 characters long.
	 *
	 */ 169 2 182 5 18446744073709551615 8 template 183 2 183 10 18446744073709551615 1 < 183 11 183 12 18446744073709551615 5 class 183 12 183 17 18446744073709551615 1 F 183 18 183 19 40 1 > 183 19 183 20 18446744073709551615 4 Task 184 2 184 6 1 1 ( 184 6 184 7 18446744073709551615 1 F 184 7 184 8 40 2 && 184 8 184 10 18446744073709551615 8 function 184 11 184 19 41 1 , 184 19 184 20 18446744073709551615 5 const 184 21 184 26 18446744073709551615 4 char 184 27 184 31 18446744073709551615 1 * 184 31 184 32 18446744073709551615 4 name 184 33 184 37 42 1 ) 184 37 184 38 18446744073709551615 1 : 185 6 185 7 18446744073709551615 4 Task 185 8 185 12 1 1 ( 185 12 185 13 18446744073709551615 3 std 185 13 185 16 5 2 :: 185 16 185 18 18446744073709551615 7 forward 185 18 185 25 28 1 < 185 25 185 26 18446744073709551615 1 F 185 26 185 27 40 1 > 185 27 185 28 18446744073709551615 1 ( 185 28 185 29 18446744073709551615 8 function 185 29 185 37 41 1 ) 185 37 185 38 18446744073709551615 1 , 185 38 185 39 18446744073709551615 21 TASK_PRIORITY_DEFAULT 185 40 185 61 18446744073709551615 1 , 185 61 185 62 18446744073709551615 24 TASK_STACK_DEPTH_DEFAULT 185 63 185 87 18446744073709551615 1 , 185 87 185 88 18446744073709551615 4 name 185 89 185 93 42 1 ) 185 93 185 94 18446744073709551615 1 { 185 95 185 96 18446744073709551615 1 } 185 96 185 97 18446744073709551615 172 /**
	 * Create a C++ task object from a task handle
	 *
	 * \param task
	 *        A task handle from task_create() for which to create a pros::Task
	 *        object.
	 */ 187 2 193 5 18446744073709551615 8 explicit 194 2 194 10 18446744073709551615 4 Task 194 11 194 15 1 1 ( 194 15 194 16 1 6 task_t 194 16 194 22 13 4 task 194 23 194 27 43 1 ) 194 27 194 28 1 1 ; 194 28 194 29 18446744073709551615 43 /**
	 * Get the currently running Task
	 */ 196 2 198 5 18446744073709551615 6 static 199 2 199 8 18446744073709551615 4 Task 199 9 199 13 1 7 current 199 14 199 21 44 1 ( 199 21 199 22 44 1 ) 199 22 199 23 44 1 ; 199 23 199 24 18446744073709551615 200 /**
	 * Creates a new task and add it to the list of tasks that are ready to run.
	 *
	 * \param in
	 *        A task handle from task_create() for which to create a pros::Task
	 *        object.
	 */ 201 2 207 5 18446744073709551615 4 Task 208 2 208 6 1 1 & 208 6 208 7 45 8 operator 208 8 208 16 45 1 = 208 16 208 17 45 1 ( 208 17 208 18 45 6 task_t 208 18 208 24 13 2 in 208 25 208 27 46 1 ) 208 27 208 28 45 1 ; 208 28 208 29 18446744073709551615 285 /**
	 * Removes the Task from the RTOS real time kernel's management. This task
	 * will be removed from all ready, blocked, suspended and event lists.
	 *
	 * Memory dynamically allocated by the task is not automatically freed, and
	 * should be freed before the task is deleted.
	 */ 210 2 216 5 18446744073709551615 4 void 217 2 217 6 18446744073709551615 6 remove 217 7 217 13 47 1 ( 217 13 217 14 47 1 ) 217 14 217 15 47 1 ; 217 15 217 16 18446744073709551615 94 /**
	 * Gets the priority of the specified task.
	 *
	 * \return The priority of the task
	 */ 219 2 223 5 18446744073709551615 3 std 224 2 224 5 5 2 :: 224 5 224 7 48 8 uint32_t 224 7 224 15 48 12 get_priority 224 16 224 28 48 1 ( 224 28 224 29 48 1 ) 224 29 224 30 48 1 ; 224 30 224 31 18446744073709551615 295 /**
	 * Sets the priority of the specified task.
	 *
	 * If the specified task's state is available to be scheduled (e.g. not
	 * blocked) and new priority is higher than the currently running task,
	 * a context switch may occur.
	 *
	 * \param prio
	 *        The new priority of the task
	 */ 226 2 235 5 18446744073709551615 4 void 236 2 236 6 18446744073709551615 12 set_priority 236 7 236 19 49 1 ( 236 19 236 20 49 3 std 236 20 236 23 5 2 :: 236 23 236 25 18446744073709551615 8 uint32_t 236 25 236 33 50 4 prio 236 34 236 38 50 1 ) 236 38 236 39 49 1 ; 236 39 236 40 18446744073709551615 88 /**
	 * Gets the state of the specified task.
	 *
	 * \return The state of the task
	 */ 238 2 242 5 18446744073709551615 3 std 243 2 243 5 5 2 :: 243 5 243 7 51 8 uint32_t 243 7 243 15 51 9 get_state 243 16 243 25 51 1 ( 243 25 243 26 51 1 ) 243 26 243 27 51 1 ; 243 27 243 28 18446744073709551615 79 /**
	 * Suspends the specified task, making it ineligible to be scheduled.
	 */ 245 2 247 5 18446744073709551615 4 void 248 2 248 6 18446744073709551615 7 suspend 248 7 248 14 52 1 ( 248 14 248 15 52 1 ) 248 15 248 16 52 1 ; 248 16 248 17 18446744073709551615 126 /**
	 * Resumes the specified task, making it eligible to be scheduled.
	 *
	 * \param task
	 *        The task to resume
	 */ 250 2 255 5 18446744073709551615 4 void 256 2 256 6 18446744073709551615 6 resume 256 7 256 13 53 1 ( 256 13 256 14 53 1 ) 256 14 256 15 53 1 ; 256 15 256 16 18446744073709551615 99 /**
	 * Gets the name of the specified task.
	 *
	 * \return A pointer to the name of the task
	 */ 258 2 262 5 18446744073709551615 5 const 263 2 263 7 18446744073709551615 4 char 263 8 263 12 18446744073709551615 1 * 263 12 263 13 54 8 get_name 263 14 263 22 54 1 ( 263 22 263 23 54 1 ) 263 23 263 24 54 1 ; 263 24 263 25 18446744073709551615 53 /**
	 * Convert this object to a C task_t handle
	 */ 265 2 267 5 18446744073709551615 8 explicit 268 2 268 10 18446744073709551615 8 operator 268 11 268 19 55 6 task_t 268 20 268 26 13 1 ( 268 26 268 27 18446744073709551615 1 ) 268 27 268 28 18446744073709551615 1 { 268 29 268 30 18446744073709551615 6 return 269 3 269 9 18446744073709551615 4 task 269 10 269 14 56 1 ; 269 14 269 15 18446744073709551615 1 } 270 2 270 3 18446744073709551615 226 /**
	 * Sends a simple notification to task and increments the notification
	 * counter.
	 *
	 * See https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html for
	 * details.
	 *
	 * \return Always returns true.
	 */ 272 2 280 5 18446744073709551615 3 std 281 2 281 5 5 2 :: 281 5 281 7 57 8 uint32_t 281 7 281 15 57 6 notify 281 16 281 22 57 1 ( 281 22 281 23 57 1 ) 281 23 281 24 57 1 ; 281 24 281 25 18446744073709551615 293 /**
	 * Utilizes task notifications to wait until specified task is complete and deleted,
	 * then continues to execute the program. Analogous to std::thread::join in C++.
	 *
	 * See https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html for
	 * details.
	 *
	 * \return void
	 */ 283 2 291 5 18446744073709551615 4 void 292 2 292 6 18446744073709551615 4 join 292 7 292 11 58 1 ( 292 11 292 12 58 1 ) 292 12 292 13 58 1 ; 292 13 292 14 18446744073709551615 836 /**
	 * Sends a notification to a task, optionally performing some action. Will
	 * also retrieve the value of the notification in the target task before
	 * modifying the notification value.
	 *
	 * See https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html for
	 * details.
	 *
	 * \param value
	 *        The value used in performing the action
	 * \param action
	 *        An action to optionally perform on the receiving task's notification
	 *        value
	 * \param prev_value
	 *        A pointer to store the previous value of the target task's
	 *        notification, may be NULL
	 *
	 * \return Dependent on the notification action.
	 * For NOTIFY_ACTION_NO_WRITE: return 0 if the value could be written without
	 * needing to overwrite, 1 otherwise.
	 * For all other NOTIFY_ACTION values: always return 0
	 */ 294 2 315 5 18446744073709551615 3 std 316 2 316 5 5 2 :: 316 5 316 7 59 8 uint32_t 316 7 316 15 59 10 notify_ext 316 16 316 26 59 1 ( 316 26 316 27 59 3 std 316 27 316 30 5 2 :: 316 30 316 32 18446744073709551615 8 uint32_t 316 32 316 40 60 5 value 316 41 316 46 60 1 , 316 46 316 47 59 17 notify_action_e_t 316 48 316 65 61 6 action 316 66 316 72 62 1 , 316 72 316 73 59 3 std 316 74 316 77 5 2 :: 316 77 316 79 18446744073709551615 8 uint32_t 316 79 316 87 63 1 * 316 87 316 88 18446744073709551615 10 prev_value 316 89 316 99 63 1 ) 316 99 316 100 59 1 ; 316 100 316 101 18446744073709551615 528 /**
	 * Waits for a notification to be nonzero.
	 *
	 * See https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html for
	 * details.
	 *
	 * \param clear_on_exit
	 *        If true (1), then the notification value is cleared.
	 *        If false (0), then the notification value is decremented.
	 * \param timeout
	 *        Specifies the amount of time to be spent waiting for a notification
	 *        to occur.
	 *
	 * \return The value of the task's notification value before it is decremented
	 * or cleared
	 */ 318 2 333 5 18446744073709551615 6 static 334 2 334 8 18446744073709551615 3 std 334 9 334 12 5 2 :: 334 12 334 14 64 8 uint32_t 334 14 334 22 64 11 notify_take 334 23 334 34 64 1 ( 334 34 334 35 64 4 bool 334 35 334 39 18446744073709551615 13 clear_on_exit 334 40 334 53 65 1 , 334 53 334 54 64 3 std 334 55 334 58 5 2 :: 334 58 334 60 18446744073709551615 8 uint32_t 334 60 334 68 66 7 timeout 334 69 334 76 66 1 ) 334 76 334 77 64 1 ; 334 77 334 78 18446744073709551615 225 /**
	 * Clears the notification for a task.
	 *
	 * See https://pros.cs.purdue.edu/v5/tutorials/topical/notifications.html for
	 * details.
	 *
	 * \return False if there was not a notification waiting, true if there was
	 */ 336 2 343 5 18446744073709551615 4 bool 344 2 344 6 18446744073709551615 12 notify_clear 344 7 344 19 67 1 ( 344 19 344 20 67 1 ) 344 20 344 21 67 1 ; 344 21 344 22 18446744073709551615 373 /**
	 * Delays a task for a given number of milliseconds.
	 *
	 * This is not the best method to have a task execute code at predefined
	 * intervals, as the delay time is measured from when the delay is requested.
	 * To delay cyclically, use task_delay_until().
	 *
	 * \param milliseconds
	 *        The number of milliseconds to wait (1000 milliseconds per second)
	 */ 346 2 355 5 18446744073709551615 6 static 356 2 356 8 18446744073709551615 4 void 356 9 356 13 18446744073709551615 5 delay 356 14 356 19 68 1 ( 356 19 356 20 68 5 const 356 20 356 25 18446744073709551615 3 std 356 26 356 29 5 2 :: 356 29 356 31 18446744073709551615 8 uint32_t 356 31 356 39 69 12 milliseconds 356 40 356 52 69 1 ) 356 52 356 53 68 1 ; 356 53 356 54 18446744073709551615 566 /**
	 * Delays a task until a specified time.  This function can be used by
	 * periodic tasks to ensure a constant execution frequency.
	 *
	 * The task will be woken up at the time *prev_time + delta, and *prev_time
	 * will be updated to reflect the time at which the task will unblock.
	 *
	 * \param prev_time
	 *        A pointer to the location storing the setpoint time. This should
	 *        typically be initialized to the return value from pros::millis().
	 * \param delta
	 *        The number of milliseconds to wait (1000 milliseconds per second)
	 */ 358 2 370 5 18446744073709551615 6 static 371 2 371 8 18446744073709551615 4 void 371 9 371 13 18446744073709551615 11 delay_until 371 14 371 25 70 1 ( 371 25 371 26 70 3 std 371 26 371 29 5 2 :: 371 29 371 31 18446744073709551615 8 uint32_t 371 31 371 39 71 1 * 371 39 371 40 18446744073709551615 5 const 371 41 371 46 18446744073709551615 9 prev_time 371 47 371 56 71 1 , 371 56 371 57 70 5 const 371 58 371 63 18446744073709551615 3 std 371 64 371 67 5 2 :: 371 67 371 69 18446744073709551615 8 uint32_t 371 69 371 77 72 5 delta 371 78 371 83 72 1 ) 371 83 371 84 70 1 ; 371 84 371 85 18446744073709551615 385 /**
	 * Gets the number of tasks the kernel is currently managing, including all
	 * ready, blocked, or suspended tasks. A task that has been deleted, but not
	 * yet reaped by the idle task will also be included in the count.
	 * Tasks recently created may take one context switch to be counted.
	 *
	 * \return The number of tasks that are currently being managed by the kernel.
	 */ 373 2 380 5 18446744073709551615 6 static 381 2 381 8 18446744073709551615 3 std 381 9 381 12 5 2 :: 381 12 381 14 73 8 uint32_t 381 14 381 22 73 9 get_count 381 23 381 32 73 1 ( 381 32 381 33 73 1 ) 381 33 381 34 73 1 ; 381 34 381 35 18446744073709551615 7 private 383 2 383 9 18446744073709551615 1 : 383 9 383 10 18446744073709551615 6 task_t 384 2 384 8 13 4 task 384 9 384 13 56 1 { 384 13 384 14 18446744073709551615 1 } 384 14 384 15 18446744073709551615 1 ; 384 15 384 16 18446744073709551615 1 } 385 1 385 2 18446744073709551615 1 ; 385 2 385 3 18446744073709551615 28 // STL Clock compliant clock 387 1 387 29 18446744073709551615 6 struct 388 1 388 7 18446744073709551615 5 Clock 388 8 388 13 74 1 { 388 14 388 15 18446744073709551615 5 using 389 2 389 7 18446744073709551615 3 rep 389 8 389 11 75 1 = 389 12 389 13 18446744073709551615 3 std 389 14 389 17 5 2 :: 389 17 389 19 18446744073709551615 8 uint32_t 389 19 389 27 75 1 ; 389 27 389 28 18446744073709551615 5 using 390 2 390 7 18446744073709551615 6 period 390 8 390 14 76 1 = 390 15 390 16 18446744073709551615 3 std 390 17 390 20 5 2 :: 390 20 390 22 18446744073709551615 5 milli 390 22 390 27 77 1 ; 390 27 390 28 18446744073709551615 5 using 391 2 391 7 18446744073709551615 8 duration 391 8 391 16 78 1 = 391 17 391 18 18446744073709551615 3 std 391 19 391 22 5 2 :: 391 22 391 24 18446744073709551615 6 chrono 391 24 391 30 79 2 :: 391 30 391 32 18446744073709551615 8 duration 391 32 391 40 80 1 < 391 40 391 41 18446744073709551615 3 rep 391 41 391 44 75 1 , 391 44 391 45 18446744073709551615 6 period 391 46 391 52 76 1 > 391 52 391 53 18446744073709551615 1 ; 391 53 391 54 18446744073709551615 5 using 392 2 392 7 18446744073709551615 10 time_point 392 8 392 18 81 1 = 392 19 392 20 18446744073709551615 3 std 392 21 392 24 5 2 :: 392 24 392 26 18446744073709551615 6 chrono 392 26 392 32 79 2 :: 392 32 392 34 18446744073709551615 10 time_point 392 34 392 44 82 1 < 392 44 392 45 18446744073709551615 5 Clock 392 45 392 50 74 1 > 392 50 392 51 18446744073709551615 1 ; 392 51 392 52 18446744073709551615 5 const 393 2 393 7 18446744073709551615 4 bool 393 8 393 12 18446744073709551615 9 is_steady 393 13 393 22 83 1 = 393 23 393 24 18446744073709551615 4 true 393 25 393 29 18446744073709551615 1 ; 393 29 393 30 18446744073709551615 120 /**
	 * Gets the current time.
	 *
	 * Effectively a wrapper around pros::millis()
	 *
	 * \return The current time
	 */ 395 2 401 5 18446744073709551615 6 static 402 2 402 8 18446744073709551615 10 time_point 402 9 402 19 81 3 now 402 20 402 23 84 1 ( 402 23 402 24 84 1 ) 402 24 402 25 84 1 ; 402 25 402 26 18446744073709551615 1 } 403 1 403 2 18446744073709551615 1 ; 403 2 403 3 18446744073709551615 5 class 405 1 405 6 18446744073709551615 5 Mutex 405 7 405 12 85 1 { 405 13 405 14 18446744073709551615 3 std 406 2 406 5 85 2 :: 406 5 406 7 18446744073709551615 10 shared_ptr 406 7 406 17 85 1 < 406 17 406 18 18446744073709551615 3 std 406 18 406 21 85 2 :: 406 21 406 23 18446744073709551615 16 remove_pointer_t 406 23 406 39 85 1 < 406 39 406 40 18446744073709551615 7 mutex_t 406 40 406 47 85 2 >> 406 47 406 49 18446744073709551615 5 mutex 406 50 406 55 86 1 ; 406 55 406 56 18446744073709551615 6 public 408 2 408 8 18446744073709551615 1 : 408 8 408 9 18446744073709551615 5 Mutex 409 2 409 7 85 1 ( 409 7 409 8 85 1 ) 409 8 409 9 85 1 ; 409 9 409 10 18446744073709551615 75 // disable copy and move construction and assignment per Mutex requirements 411 2 411 77 18446744073709551615 58 // (see https://en.cppreference.com/w/cpp/named_req/Mutex) 412 2 412 60 18446744073709551615 5 Mutex 413 2 413 7 85 1 ( 413 7 413 8 85 5 const 413 8 413 13 18446744073709551615 5 Mutex 413 14 413 19 85 1 & 413 19 413 20 18446744073709551615 1 ) 413 20 413 21 85 1 = 413 22 413 23 85 6 delete 413 24 413 30 18446744073709551615 1 ; 413 30 413 31 18446744073709551615 5 Mutex 414 2 414 7 85 1 ( 414 7 414 8 85 5 Mutex 414 8 414 13 85 2 && 414 13 414 15 18446744073709551615 1 ) 414 15 414 16 85 1 = 414 17 414 18 85 6 delete 414 19 414 25 18446744073709551615 1 ; 414 25 414 26 18446744073709551615 5 Mutex 416 2 416 7 85 1 & 416 7 416 8 87 8 operator 416 9 416 17 87 1 = 416 17 416 18 87 1 ( 416 18 416 19 87 5 const 416 19 416 24 18446744073709551615 5 Mutex 416 25 416 30 85 1 & 416 30 416 31 18446744073709551615 1 ) 416 31 416 32 87 1 = 416 33 416 34 87 6 delete 416 35 416 41 18446744073709551615 1 ; 416 41 416 42 18446744073709551615 5 Mutex 417 2 417 7 85 1 & 417 7 417 8 87 8 operator 417 9 417 17 87 1 = 417 17 417 18 87 1 ( 417 18 417 19 87 5 Mutex 417 19 417 24 85 2 && 417 24 417 26 18446744073709551615 1 ) 417 26 417 27 87 1 = 417 28 417 29 87 6 delete 417 30 417 36 18446744073709551615 1 ; 417 36 417 37 18446744073709551615 334 /**
	 * Takes and locks a mutex indefinetly.
	 *
	 * See
	 * https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes
	 * for details.
	 *
	 * \return True if the mutex was successfully taken, false otherwise. If false
	 * is returned, then errno is set with a hint about why the the mutex
	 * couldn't be taken.
	 */ 419 2 429 5 18446744073709551615 4 bool 430 2 430 6 18446744073709551615 4 take 430 7 430 11 88 1 ( 430 11 430 12 88 1 ) 430 12 430 13 88 1 ; 430 13 430 14 18446744073709551615 594 /**
	 * Takes and locks a mutex, waiting for up to a certain number of milliseconds
	 * before timing out.
	 *
	 * See
	 * https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes
	 * for details.
	 *
	 * \param timeout
	 *        Time to wait before the mutex becomes available. A timeout of 0 can
	 *        be used to poll the mutex. TIMEOUT_MAX can be used to block
	 *        indefinitely.
	 *
	 * \return True if the mutex was successfully taken, false otherwise. If false
	 * is returned, then errno is set with a hint about why the the mutex
	 * couldn't be taken.
	 */ 432 2 448 5 18446744073709551615 4 bool 449 2 449 6 18446744073709551615 4 take 449 7 449 11 88 1 ( 449 11 449 12 88 3 std 449 12 449 15 5 2 :: 449 15 449 17 18446744073709551615 8 uint32_t 449 17 449 25 89 7 timeout 449 26 449 33 89 1 ) 449 33 449 34 88 1 ; 449 34 449 35 18446744073709551615 316 /**
	 * Unlocks a mutex.
	 *
	 * See
	 * https://pros.cs.purdue.edu/v5/tutorials/topical/multitasking.html#mutexes
	 * for details.
	 *
	 * \return True if the mutex was successfully returned, false otherwise. If
	 * false is returned, then errno is set with a hint about why the mutex
	 * couldn't be returned.
	 */ 451 2 461 5 18446744073709551615 4 bool 462 2 462 6 18446744073709551615 4 give 462 7 462 11 90 1 ( 462 11 462 12 90 1 ) 462 12 462 13 90 1 ; 462 13 462 14 18446744073709551615 566 /**
	 * Takes and locks a mutex, waiting for up to TIMEOUT_MAX milliseconds.
	 *
	 * Effectively equivalent to calling pros::Mutex::take with TIMEOUT_MAX as
	 * the parameter.
	 *
	 * Conforms to named requirment BasicLockable
	 * \see https://en.cppreference.com/w/cpp/named_req/BasicLockable
	 *
	 * \note Consider using a std::unique_lock, std::lock_guard, or
	 * 		 std::scoped_lock instead of interacting with the Mutex directly.
	 *
	 * \exception std::system_error Mutex could not be locked within TIMEOUT_MAX
	 *			  milliseconds. see errno for details.
	 */ 464 2 478 5 18446744073709551615 4 void 479 2 479 6 18446744073709551615 4 lock 479 7 479 11 91 1 ( 479 11 479 12 91 1 ) 479 12 479 13 91 1 ; 479 13 479 14 18446744073709551615 337 /**
	 * Unlocks a mutex.
	 *
	 * Equivalent to calling pros::Mutex::give.
	 *
	 * Conforms to named requirement BasicLockable
	 * \see https://en.cppreference.com/w/cpp/named_req/BasicLockable
	 *
	 * \note Consider using a std::unique_lock, std::lock_guard, or
	 * 		 std::scoped_lock instead of interacting with the Mutex direcly.
	 */ 481 2 491 5 18446744073709551615 4 void 492 2 492 6 18446744073709551615 6 unlock 492 7 492 13 92 1 ( 492 13 492 14 92 1 ) 492 14 492 15 92 1 ; 492 15 492 16 18446744073709551615 263 /**
	 * Try to lock a mutex.
	 *
	 * Returns immediately if unsucessful.
	 *
	 * Conforms to named requirement Lockable
	 * \see https://en.cppreference.com/w/cpp/named_req/Lockable
	 *
	 * \return True when lock was acquired succesfully, or false otherwise.
	 */ 494 2 503 5 18446744073709551615 4 bool 504 2 504 6 18446744073709551615 8 try_lock 504 7 504 15 93 1 ( 504 15 504 16 93 1 ) 504 16 504 17 93 1 ; 504 17 504 18 18446744073709551615 430 /**
	 * Takes and locks a mutex, waiting for a specified duration.
	 *
	 * Equivalent to calling pros::Mutex::take with a duration specified in
	 * milliseconds.
	 *
	 * Conforms to named requirement TimedLockable
	 * \see https://en.cppreference.com/w/cpp/named_req/TimedLockable
	 *
	 * \param rel_time Time to wait before the mutex becomes available.
	 * \return True if the lock was acquired succesfully, otherwise false.
	 */ 506 2 517 5 18446744073709551615 8 template 518 2 518 10 18446744073709551615 1 < 518 11 518 12 18446744073709551615 8 typename 518 12 518 20 18446744073709551615 3 Rep 518 21 518 24 94 1 , 518 24 518 25 18446744073709551615 8 typename 518 26 518 34 18446744073709551615 6 Period 518 35 518 41 95 1 > 518 41 518 42 18446744073709551615 4 bool 519 2 519 6 18446744073709551615 12 try_lock_for 519 7 519 19 96 1 ( 519 19 519 20 18446744073709551615 5 const 519 20 519 25 18446744073709551615 3 std 519 26 519 29 5 2 :: 519 29 519 31 18446744073709551615 6 chrono 519 31 519 37 79 2 :: 519 37 519 39 18446744073709551615 8 duration 519 39 519 47 80 1 < 519 47 519 48 18446744073709551615 3 Rep 519 48 519 51 94 1 , 519 51 519 52 18446744073709551615 6 Period 519 53 519 59 95 1 > 519 59 519 60 18446744073709551615 1 & 519 60 519 61 18446744073709551615 8 rel_time 519 62 519 70 97 1 ) 519 70 519 71 18446744073709551615 1 { 519 72 519 73 18446744073709551615 6 return 520 3 520 9 18446744073709551615 4 take 520 10 520 14 98 1 ( 520 14 520 15 18446744073709551615 3 std 520 15 520 18 5 2 :: 520 18 520 20 18446744073709551615 6 chrono 520 20 520 26 79 2 :: 520 26 520 28 18446744073709551615 13 duration_cast 520 28 520 41 99 1 < 520 41 520 42 18446744073709551615 5 Clock 520 42 520 47 74 2 :: 520 47 520 49 18446744073709551615 8 duration 520 49 520 57 78 1 > 520 57 520 58 18446744073709551615 1 ( 520 58 520 59 18446744073709551615 8 rel_time 520 59 520 67 97 1 ) 520 67 520 68 18446744073709551615 1 . 520 68 520 69 18446744073709551615 5 count 520 69 520 74 18446744073709551615 1 ( 520 74 520 75 18446744073709551615 1 ) 520 75 520 76 18446744073709551615 1 ) 520 76 520 77 18446744073709551615 1 ; 520 77 520 78 18446744073709551615 1 } 521 2 521 3 18446744073709551615 330 /**
	 * Takes and locks a mutex, waiting until a specified time.
	 *
	 * Conforms to named requirement TimedLockable
	 * \see https://en.cppreference.com/w/cpp/named_req/TimedLockable
	 *
	 * \param abs_time Time point until which to wait for the mutex.
	 * \return True if the lock was acquired succesfully, otherwise false.
	 */ 523 2 531 5 18446744073709551615 8 template 532 2 532 10 18446744073709551615 1 < 532 11 532 12 18446744073709551615 8 typename 532 12 532 20 18446744073709551615 8 Duration 532 21 532 29 100 1 > 532 29 532 30 18446744073709551615 4 bool 533 2 533 6 18446744073709551615 14 try_lock_until 533 7 533 21 101 1 ( 533 21 533 22 18446744073709551615 5 const 533 22 533 27 18446744073709551615 3 std 533 28 533 31 5 2 :: 533 31 533 33 18446744073709551615 6 chrono 533 33 533 39 79 2 :: 533 39 533 41 18446744073709551615 10 time_point 533 41 533 51 82 1 < 533 51 533 52 18446744073709551615 5 Clock 533 52 533 57 74 1 , 533 57 533 58 18446744073709551615 8 Duration 533 59 533 67 100 1 > 533 67 533 68 18446744073709551615 1 & 533 68 533 69 18446744073709551615 8 abs_time 533 70 533 78 102 1 ) 533 78 533 79 18446744073709551615 1 { 533 80 533 81 18446744073709551615 6 return 534 3 534 9 18446744073709551615 4 take 534 10 534 14 98 1 ( 534 14 534 15 18446744073709551615 3 std 534 15 534 18 5 2 :: 534 18 534 20 18446744073709551615 3 max 534 20 534 23 103 1 ( 534 23 534 24 18446744073709551615 11 static_cast 534 24 534 35 18446744073709551615 1 < 534 35 534 36 18446744073709551615 8 uint32_t 534 36 534 44 104 1 > 534 44 534 45 18446744073709551615 1 ( 534 45 534 46 18446744073709551615 1 0 534 46 534 47 18446744073709551615 1 ) 534 47 534 48 18446744073709551615 1 , 534 48 534 49 18446744073709551615 1 ( 534 50 534 51 18446744073709551615 8 abs_time 534 51 534 59 102 1 - 534 60 534 61 18446744073709551615 5 Clock 534 62 534 67 74 2 :: 534 67 534 69 84 3 now 534 69 534 72 84 1 ( 534 72 534 73 84 1 ) 534 73 534 74 84 1 ) 534 74 534 75 18446744073709551615 1 . 534 75 534 76 18446744073709551615 5 count 534 76 534 81 18446744073709551615 1 ( 534 81 534 82 18446744073709551615 1 ) 534 82 534 83 18446744073709551615 1 ) 534 83 534 84 18446744073709551615 1 ) 534 84 534 85 18446744073709551615 1 ; 534 85 534 86 18446744073709551615 1 } 535 2 535 3 18446744073709551615 1 } 536 1 536 2 18446744073709551615 1 ; 536 2 536 3 18446744073709551615 8 template 538 1 538 9 18446744073709551615 1 < 538 10 538 11 18446744073709551615 8 typename 538 11 538 19 18446744073709551615 3 Var 538 20 538 23 105 1 > 538 23 538 24 18446744073709551615 5 class 539 1 539 6 18446744073709551615 8 MutexVar 539 7 539 15 106 1 ; 539 15 539 16 18446744073709551615 8 template 541 1 541 9 18446744073709551615 1 < 541 10 541 11 18446744073709551615 8 typename 541 11 541 19 18446744073709551615 3 Var 541 20 541 23 107 1 > 541 23 541 24 18446744073709551615 5 class 542 1 542 6 18446744073709551615 12 MutexVarLock 542 7 542 19 108 1 { 542 20 542 21 18446744073709551615 5 Mutex 543 2 543 7 85 1 & 543 7 543 8 18446744073709551615 5 mutex 543 9 543 14 109 1 ; 543 14 543 15 18446744073709551615 3 Var 544 2 544 5 107 1 & 544 5 544 6 18446744073709551615 3 var 544 7 544 10 110 1 ; 544 10 544 11 18446744073709551615 6 friend 546 2 546 8 18446744073709551615 5 class 546 9 546 14 18446744073709551615 8 MutexVar 546 15 546 23 106 1 < 546 23 546 24 18446744073709551615 3 Var 546 24 546 27 107 1 > 546 27 546 28 18446744073709551615 1 ; 546 28 546 29 18446744073709551615 9 constexpr 548 2 548 11 18446744073709551615 12 MutexVarLock 548 12 548 24 108 1 ( 548 24 548 25 108 5 Mutex 548 25 548 30 85 1 & 548 30 548 31 18446744073709551615 5 mutex 548 32 548 37 111 1 , 548 37 548 38 108 3 Var 548 39 548 42 107 1 & 548 42 548 43 18446744073709551615 3 var 548 44 548 47 112 1 ) 548 47 548 48 108 1 : 548 49 548 50 108 5 mutex 548 51 548 56 109 1 ( 548 56 548 57 108 5 mutex 548 57 548 62 111 1 ) 548 62 548 63 108 1 , 548 63 548 64 108 3 var 548 65 548 68 110 1 ( 548 68 548 69 18446744073709551615 3 var 548 69 548 72 112 1 ) 548 72 548 73 18446744073709551615 1 { 548 74 548 75 18446744073709551615 1 } 548 75 548 76 18446744073709551615 6 public 550 2 550 8 18446744073709551615 1 : 550 8 550 9 18446744073709551615 64 /**
	 * Accesses the value of the mutex-protected variable.
	 */ 551 2 553 5 18446744073709551615 9 constexpr 554 2 554 11 18446744073709551615 3 Var 554 12 554 15 107 1 & 554 15 554 16 113 8 operator 554 17 554 25 113 1 * 554 25 554 26 113 1 ( 554 26 554 27 113 1 ) 554 27 554 28 113 5 const 554 29 554 34 18446744073709551615 1 { 554 35 554 36 18446744073709551615 6 return 555 3 555 9 18446744073709551615 3 var 555 10 555 13 110 1 ; 555 13 555 14 18446744073709551615 1 } 556 2 556 3 18446744073709551615 64 /**
	 * Accesses the value of the mutex-protected variable.
	 */ 558 2 560 5 18446744073709551615 9 constexpr 561 2 561 11 18446744073709551615 3 Var 561 12 561 15 107 1 * 561 15 561 16 114 8 operator 561 17 561 25 114 2 -> 561 25 561 27 114 1 ( 561 27 561 28 114 1 ) 561 28 561 29 114 5 const 561 30 561 35 18446744073709551615 1 { 561 36 561 37 18446744073709551615 6 return 562 3 562 9 18446744073709551615 1 & 562 10 562 11 18446744073709551615 3 var 562 11 562 14 110 1 ; 562 14 562 15 18446744073709551615 1 } 563 2 563 3 18446744073709551615 1 ~ 565 2 565 3 18446744073709551615 12 MutexVarLock 565 3 565 15 108 1 ( 565 15 565 16 18446744073709551615 1 ) 565 16 565 17 18446744073709551615 1 { 565 18 565 19 18446744073709551615 5 mutex 566 3 566 8 109 1 . 566 8 566 9 92 6 unlock 566 9 566 15 92 1 ( 566 15 566 16 92 1 ) 566 16 566 17 92 1 ; 566 17 566 18 18446744073709551615 1 } 567 2 567 3 18446744073709551615 1 } 568 1 568 2 18446744073709551615 1 ; 568 2 568 3 18446744073709551615 8 template 570 1 570 9 18446744073709551615 1 < 570 10 570 11 18446744073709551615 8 typename 570 11 570 19 18446744073709551615 3 Var 570 20 570 23 105 1 > 570 23 570 24 18446744073709551615 5 class 571 1 571 6 18446744073709551615 8 MutexVar 571 7 571 15 106 1 { 571 16 571 17 18446744073709551615 5 Mutex 572 2 572 7 85 5 mutex 572 8 572 13 115 1 ; 572 13 572 14 18446744073709551615 3 Var 573 2 573 5 105 3 var 573 6 573 9 116 1 ; 573 9 573 10 18446744073709551615 6 public 575 2 575 8 18446744073709551615 1 : 575 8 575 9 18446744073709551615 190 /**
	 * Creates a mutex-protected variable which is initialized with the given
	 * constructor arguments.
	 *
	 * \param args
	          The arguments to provide to the Var constructor.
	 */ 576 2 582 5 18446744073709551615 8 template 583 2 583 10 18446744073709551615 1 < 583 11 583 12 18446744073709551615 8 typename 583 12 583 20 18446744073709551615 3 ... 583 20 583 23 18446744073709551615 4 Args 583 24 583 28 117 1 > 583 28 583 29 18446744073709551615 8 MutexVar 584 2 584 10 106 1 ( 584 10 584 11 18446744073709551615 4 Args 584 11 584 15 117 2 && 584 15 584 17 18446744073709551615 3 ... 584 17 584 20 18446744073709551615 4 args 584 21 584 25 118 1 ) 584 25 584 26 18446744073709551615 1 : 584 27 584 28 18446744073709551615 5 mutex 584 29 584 34 115 1 ( 584 34 584 35 85 1 ) 584 35 584 36 85 1 , 584 36 584 37 18446744073709551615 3 var 584 38 584 41 116 1 ( 584 41 584 42 18446744073709551615 3 std 584 42 584 45 5 2 :: 584 45 584 47 18446744073709551615 7 forward 584 47 584 54 28 1 < 584 54 584 55 18446744073709551615 4 Args 584 55 584 59 117 1 > 584 59 584 60 18446744073709551615 1 ( 584 60 584 61 18446744073709551615 4 args 584 61 584 65 118 1 ) 584 65 584 66 18446744073709551615 3 ... 584 66 584 69 18446744073709551615 1 ) 584 69 584 70 18446744073709551615 1 { 584 71 584 72 18446744073709551615 1 } 584 72 584 73 18446744073709551615 346 /**
	 * Try to lock the mutex-protected variable.
	 *
	 * \param timeout
	 *        Time to wait before the mutex becomes available, in milliseconds. A
	 *        timeout of 0 can be used to poll the mutex.
	 *
	 * \return A std::optional which contains a MutexVarLock providing access to
	 * the protected variable if locking is successful.
	 */ 586 2 595 5 18446744073709551615 3 std 596 2 596 5 5 2 :: 596 5 596 7 119 8 optional 596 7 596 15 120 1 < 596 15 596 16 119 12 MutexVarLock 596 16 596 28 108 1 < 596 28 596 29 119 3 Var 596 29 596 32 105 2 >> 596 32 596 34 119 8 try_lock 596 35 596 43 119 1 ( 596 43 596 44 119 3 std 596 44 596 47 5 2 :: 596 47 596 49 18446744073709551615 8 uint32_t 596 49 596 57 121 7 timeout 596 58 596 65 121 1 ) 596 65 596 66 119 1 { 596 67 596 68 18446744073709551615 2 if 597 3 597 5 18446744073709551615 1 ( 597 6 597 7 18446744073709551615 5 mutex 597 7 597 12 115 1 . 597 12 597 13 88 4 take 597 13 597 17 88 1 ( 597 17 597 18 88 7 timeout 597 18 597 25 121 1 ) 597 25 597 26 88 1 ) 597 26 597 27 18446744073709551615 1 { 597 28 597 29 18446744073709551615 6 return 598 4 598 10 18446744073709551615 1 { 598 11 598 12 18446744073709551615 1 { 598 12 598 13 18446744073709551615 5 mutex 598 13 598 18 115 1 , 598 18 598 19 18446744073709551615 3 var 598 20 598 23 116 1 } 598 23 598 24 18446744073709551615 1 } 598 24 598 25 18446744073709551615 1 ; 598 25 598 26 18446744073709551615 1 } 599 3 599 4 18446744073709551615 4 else 599 5 599 9 18446744073709551615 1 { 599 10 599 11 18446744073709551615 6 return 600 4 600 10 18446744073709551615 1 { 600 11 600 12 18446744073709551615 1 } 600 12 600 13 18446744073709551615 1 ; 600 13 600 14 18446744073709551615 1 } 601 3 601 4 18446744073709551615 1 } 602 2 602 3 18446744073709551615 329 /**
	 * Try to lock the mutex-protected variable.
	 *
	 * \param timeout
	 *        Time to wait before the mutex becomes available. A timeout of 0 can
	 *        be used to poll the mutex.
	 *
	 * \return A std::optional which contains a MutexVarLock providing access to
	 * the protected variable if locking is successful.
	 */ 604 2 613 5 18446744073709551615 8 template 614 2 614 10 18446744073709551615 1 < 614 11 614 12 18446744073709551615 8 typename 614 12 614 20 18446744073709551615 3 Rep 614 21 614 24 122 1 , 614 24 614 25 18446744073709551615 8 typename 614 26 614 34 18446744073709551615 6 Period 614 35 614 41 123 1 > 614 41 614 42 18446744073709551615 3 std 615 2 615 5 5 2 :: 615 5 615 7 18446744073709551615 8 optional 615 7 615 15 120 1 < 615 15 615 16 18446744073709551615 12 MutexVarLock 615 16 615 28 108 1 < 615 28 615 29 18446744073709551615 3 Var 615 29 615 32 105 2 >> 615 32 615 34 18446744073709551615 8 try_lock 615 35 615 43 119 1 ( 615 43 615 44 18446744073709551615 5 const 615 44 615 49 18446744073709551615 3 std 615 50 615 53 5 2 :: 615 53 615 55 18446744073709551615 6 chrono 615 55 615 61 79 2 :: 615 61 615 63 18446744073709551615 8 duration 615 63 615 71 80 1 < 615 71 615 72 18446744073709551615 3 Rep 615 72 615 75 122 1 , 615 75 615 76 18446744073709551615 6 Period 615 77 615 83 123 1 > 615 83 615 84 18446744073709551615 1 & 615 84 615 85 18446744073709551615 8 rel_time 615 86 615 94 124 1 ) 615 94 615 95 18446744073709551615 1 { 615 96 615 97 18446744073709551615 8 try_lock 616 3 616 11 125 1 ( 616 11 616 12 18446744073709551615 3 std 616 12 616 15 5 2 :: 616 15 616 17 18446744073709551615 6 chrono 616 17 616 23 79 2 :: 616 23 616 25 18446744073709551615 13 duration_cast 616 25 616 38 99 1 < 616 38 616 39 18446744073709551615 5 Clock 616 39 616 44 74 2 :: 616 44 616 46 18446744073709551615 8 duration 616 46 616 54 78 1 > 616 54 616 55 18446744073709551615 1 ( 616 55 616 56 18446744073709551615 8 rel_time 616 56 616 64 124 1 ) 616 64 616 65 18446744073709551615 1 . 616 65 616 66 18446744073709551615 5 count 616 66 616 71 18446744073709551615 1 ( 616 71 616 72 18446744073709551615 1 ) 616 72 616 73 18446744073709551615 1 ) 616 73 616 74 18446744073709551615 1 ; 616 74 616 75 18446744073709551615 1 } 617 2 617 3 18446744073709551615 144 /**
	 * Lock the mutex-protected variable, waiting indefinitely.
	 *
	 * \return A MutexVarLock providing access to the protected variable.
	 */ 619 2 623 5 18446744073709551615 12 MutexVarLock 624 2 624 14 108 1 < 624 14 624 15 126 3 Var 624 15 624 18 105 1 > 624 18 624 19 126 4 lock 624 20 624 24 126 1 ( 624 24 624 25 126 1 ) 624 25 624 26 126 1 { 624 27 624 28 18446744073709551615 5 while 625 3 625 8 18446744073709551615 1 ( 625 9 625 10 18446744073709551615 1 ! 625 10 625 11 18446744073709551615 5 mutex 625 11 625 16 115 1 . 625 16 625 17 88 4 take 625 17 625 21 88 1 ( 625 21 625 22 88 11 TIMEOUT_MAX 625 22 625 33 88 1 ) 625 33 625 34 88 1 ) 625 34 625 35 18446744073709551615 1 ; 626 4 626 5 18446744073709551615 6 return 627 3 627 9 18446744073709551615 1 { 627 10 627 11 18446744073709551615 5 mutex 627 11 627 16 115 1 , 627 16 627 17 18446744073709551615 3 var 627 18 627 21 116 1 } 627 21 627 22 18446744073709551615 1 ; 627 22 627 23 18446744073709551615 1 } 628 2 628 3 18446744073709551615 1 } 629 1 629 2 18446744073709551615 1 ; 629 2 629 3 18446744073709551615 130 /**
 * Gets the number of milliseconds since PROS initialized.
 *
 * \return The number of milliseconds since PROS initialized
 */ 631 1 635 4 18446744073709551615 5 using 636 1 636 6 18446744073709551615 4 pros 636 7 636 11 0 2 :: 636 11 636 13 18446744073709551615 1 c 636 13 636 14 21 2 :: 636 14 636 16 18446744073709551615 6 millis 636 16 636 22 127 1 ; 636 22 636 23 18446744073709551615 130 /**
 * Gets the number of microseconds since PROS initialized.
 *
 * \return The number of microseconds since PROS initialized
 */ 638 1 642 4 18446744073709551615 5 using 643 1 643 6 18446744073709551615 4 pros 643 7 643 11 0 2 :: 643 11 643 13 18446744073709551615 1 c 643 13 643 14 21 2 :: 643 14 643 16 18446744073709551615 6 micros 643 16 643 22 128 1 ; 643 22 643 23 18446744073709551615 361 /**
 * Delays a task for a given number of milliseconds.
 *
 * This is not the best method to have a task execute code at predefined
 * intervals, as the delay time is measured from when the delay is requested.
 * To delay cyclically, use task_delay_until().
 *
 * \param milliseconds
 * 		  The number of milliseconds to wait (1000 milliseconds per second)
 */ 645 1 654 4 18446744073709551615 5 using 655 1 655 6 18446744073709551615 4 pros 655 7 655 11 0 2 :: 655 11 655 13 18446744073709551615 1 c 655 13 655 14 21 2 :: 655 14 655 16 18446744073709551615 5 delay 655 16 655 21 129 1 ; 655 21 655 22 18446744073709551615 1 } 656 1 656 2 18446744073709551615 17 // namespace pros 656 4 656 21 18446744073709551615 1 # 658 1 658 2 18446744073709551615 5 endif 658 2 658 7 18446744073709551615 18 // _PROS_RTOS_HPP_ 658 9 658 27 18446744073709551615 0 0 130 0 0 0 22 0 0 1 13 0 4 pros 4 1 13 0 9 Task:pros 20 1 13 0 14 task_fn_t:pros 10 1 13 0 68 62:17:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 68 62:33:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 22 1 13 0 3 std 10 1 13 0 68 62:69:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 68 63:21:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 68 63:73:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 68 84:17:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 68 84:33:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 68 84:57:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 27 1 13 0 69 106:18:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 20 1 13 0 11 task_t:pros 30 1 13 0 16 create:Task:pros 10 1 13 0 69 107:27:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 69 107:51:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 69 108:37:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 69 108:89:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 49 1 13 0 16 is_invocable_r_v 8 1 13 0 18 task_create:c:pros 22 1 13 0 6 c:pros 10 1 13 0 69 111:16:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 31 1 13 0 14 unique_ptr:std 31 1 13 0 12 function:std 9 1 13 0 69 112:47:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 21 1 13 0 24 operator*:unique_ptr:std 21 1 13 0 21 operator:function:std 49 1 13 0 7 forward 27 1 13 0 69 132:18:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 69 133:27:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 69 133:49:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 49 1 13 0 6 create 27 1 13 0 69 157:18:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 69 158:20:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 69 158:44:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 69 159:30:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 69 159:82:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 69 161:21:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 9 1 13 0 69 162:52:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 27 1 13 0 69 183:18:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 69 184:11:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 69 184:33:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 69 194:23:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 21 1 13 0 17 current:Task:pros 21 1 13 0 19 operator=:Task:pros 10 1 13 0 69 208:25:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 21 1 13 0 16 remove:Task:pros 21 1 13 0 22 get_priority:Task:pros 21 1 13 0 22 set_priority:Task:pros 10 1 13 0 69 236:34:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 21 1 13 0 19 get_state:Task:pros 21 1 13 0 17 suspend:Task:pros 21 1 13 0 16 resume:Task:pros 21 1 13 0 18 get_name:Task:pros 26 1 13 0 25 operator void *:Task:pros 6 1 13 0 14 task:Task:pros 21 1 13 0 16 notify:Task:pros 21 1 13 0 14 join:Task:pros 21 1 13 0 20 notify_ext:Task:pros 10 1 13 0 69 316:41:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 20 1 13 0 22 notify_action_e_t:pros 10 1 13 0 69 316:66:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 69 316:89:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 21 1 13 0 21 notify_take:Task:pros 10 1 13 0 69 334:40:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 69 334:69:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 21 1 13 0 22 notify_clear:Task:pros 21 1 13 0 15 delay:Task:pros 10 1 13 0 69 356:40:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 21 1 13 0 21 delay_until:Task:pros 10 1 13 0 69 371:47:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 69 371:78:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 21 1 13 0 19 get_count:Task:pros 2 1 13 0 10 Clock:pros 36 1 13 0 14 rep:Clock:pros 36 1 13 0 17 period:Clock:pros 20 1 13 0 9 milli:std 36 1 13 0 19 duration:Clock:pros 22 1 13 0 10 chrono:std 31 1 13 0 19 duration:chrono:std 36 1 13 0 21 time_point:Clock:pros 31 1 13 0 21 time_point:chrono:std 6 1 13 0 20 is_steady:Clock:pros 21 1 13 0 14 now:Clock:pros 4 1 13 0 10 Mutex:pros 6 1 13 0 16 mutex:Mutex:pros 21 1 13 0 20 operator=:Mutex:pros 21 1 13 0 15 take:Mutex:pros 10 1 13 0 69 449:26:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 21 1 13 0 15 give:Mutex:pros 21 1 13 0 15 lock:Mutex:pros 21 1 13 0 17 unlock:Mutex:pros 21 1 13 0 19 try_lock:Mutex:pros 27 1 13 0 69 518:21:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 27 1 13 0 69 518:35:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 30 1 13 0 23 try_lock_for:Mutex:pros 10 1 13 0 69 519:62:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 49 1 13 0 4 take 49 1 13 0 13 duration_cast 27 1 13 0 69 532:21:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 30 1 13 0 25 try_lock_until:Mutex:pros 10 1 13 0 69 533:70:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 49 1 13 0 3 max 20 1 13 0 8 uint32_t 27 1 13 0 17 Var:MutexVar:pros 31 1 13 0 13 MutexVar:pros 27 1 13 0 21 Var:MutexVarLock:pros 31 1 13 0 17 MutexVarLock:pros 6 1 13 0 23 mutex:MutexVarLock:pros 6 1 13 0 21 var:MutexVarLock:pros 10 1 13 0 69 548:32:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 69 548:44:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 21 1 13 0 27 operator*:MutexVarLock:pros 21 1 13 0 28 operator->:MutexVarLock:pros 6 1 13 0 19 mutex:MutexVar:pros 6 1 13 0 17 var:MutexVar:pros 27 1 13 0 69 583:24:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 69 584:21:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 21 1 13 0 22 try_lock:MutexVar:pros 31 1 13 0 12 optional:std 10 1 13 0 69 596:58:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 27 1 13 0 69 614:21:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 27 1 13 0 69 614:35:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 10 1 13 0 69 615:86:/home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 49 1 13 0 8 try_lock 21 1 13 0 18 lock:MutexVar:pros 49 1 13 0 6 millis 49 1 13 0 6 micros 49 1 13 0 5 delay 0 0 1 0 0 0 62 /home/bluecore/Desktop/Pros/Main Project/include/pros/rtos.hpp 1698321186